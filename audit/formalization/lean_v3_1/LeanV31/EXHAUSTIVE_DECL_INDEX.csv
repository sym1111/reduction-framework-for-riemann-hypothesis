"file","line","kind","name","text"
"Basic.lean","1","def","hello","def hello := ""world"""
"BcPoissonStrip.lean","5","def","StripBoundaryMaximumPrinciple","def StripBoundaryMaximumPrinciple (F : Complex -> Complex) : Prop :="
"BcPoissonStrip.lean","12","theorem","bc_poisson_strip","theorem bc_poisson_strip"
"BDetector.lean","5","def","BDetectorFunctionalOnCircle","def BDetectorFunctionalOnCircle (H : Complex -> Complex) : Prop :="
"BDetector.lean","11","theorem","b_detector","theorem b_detector"
"BDetectorGram.lean","5","def","BDetectorGramIdentity","def BDetectorGramIdentity (H : Complex -> Complex) : Prop :="
"BDetectorGram.lean","11","theorem","b_detector_gram","theorem b_detector_gram"
"CalibArithStieltjes.lean","5","def","ArithStieltjesModelAt","def ArithStieltjesModelAt (_z : Complex) : Prop :="
"CalibArithStieltjes.lean","11","theorem","calib_arith_stieltjes","theorem calib_arith_stieltjes"
"CalibKernelMatch.lean","5","def","CalibKernelMatchAt","def CalibKernelMatchAt (z : Complex) : Prop :="
"CalibKernelMatch.lean","11","theorem","calib_kernel_match","theorem calib_kernel_match"
"CanonicalTruncDetector0B21.lean","5","def","NoNegativeModesOnCircle","def NoNegativeModesOnCircle (n : Nat) : Prop := Exists fun k : Nat => k <= n"
"CanonicalTruncDetector0B21.lean","6","def","DetectorDefectZeroAtLevel","def DetectorDefectZeroAtLevel (_n : Nat) : Prop :="
"CanonicalTruncDetector0B21.lean","12","theorem","canonical_trunc_detector0","theorem canonical_trunc_detector0"
"CayleyEquiv.lean","11","theorem","cayley_equiv","theorem cayley_equiv"
"CholCert.lean","5","def","A2ApproxCholeskyResidualAt","def A2ApproxCholeskyResidualAt (z : Complex) : Prop := Exists fun w : Complex => w = z"
"CholCert.lean","6","def","A2CholCertAt","def A2CholCertAt (z : Complex) : Prop := Exists fun w : Complex => w = z"
"CholCert.lean","11","theorem","chol_cert","theorem chol_cert"
"CircleHardyCertificate.lean","6","def","CircleHardyZeroFreeCertificate","def CircleHardyZeroFreeCertificate (f _H : Complex -> Complex) : Prop :="
"CircleHardyCertificate.lean","12","theorem","circle_hardy_certificate","theorem circle_hardy_certificate"
"DiscreteLagrangeGramB21.lean","5","def","MatrixPickKernel","def MatrixPickKernel (_n : Nat) (_z _w : Complex) : Complex := 0"
"DiscreteLagrangeGramB21.lean","6","def","GramSumIdentityAt","def GramSumIdentityAt (n : Nat) (_z _w : Complex) : Prop := Exists fun k : Nat => k = n"
"DiscreteLagrangeGramB21.lean","7","def","MatrixPickKernelPSDAtLevel","def MatrixPickKernelPSDAtLevel (n : Nat) : Prop := Exists fun m : Nat => m <= n"
"DiscreteLagrangeGramB21.lean","12","theorem","discrete_lagrange_gram","theorem discrete_lagrange_gram"
"EnergyIdentityB21.lean","5","def","UpperHalfPlanePoint","def UpperHalfPlanePoint (zeta : Complex) : Prop := 0 < Complex.im zeta"
"EnergyIdentityB21.lean","6","def","RInvertibleAt","def RInvertibleAt (_zeta : Complex) (_R : Complex -> Complex) : Prop := Exists fun C : Real => 0 <= C"
"EnergyIdentityB21.lean","7","def","EnergyIdentityAt","def EnergyIdentityAt (_zeta : Complex) (_M _R _H : Complex -> Complex) : Prop :="
"EnergyIdentityB21.lean","9","def","PositiveSemidefiniteTransport","def PositiveSemidefiniteTransport (_zeta : Complex) (_R _H : Complex -> Complex) : Prop :="
"EnergyIdentityB21.lean","11","def","JContractiveAt","def JContractiveAt (_zeta : Complex) (_M : Complex -> Complex) : Prop := Exists fun n0 : Nat => 0 <= n0 /\ 0 < n0"
"EnergyIdentityB21.lean","16","theorem","energy_identity","theorem energy_identity"
"FinalBridgeClosed.lean","17","theorem","final_bridge_closed_core","theorem final_bridge_closed_core"
"FinalBridgeClosed.lean","26","theorem","final_bridge_closed_core_via_nevanlinna","theorem final_bridge_closed_core_via_nevanlinna"
"FinalBridgeClosed.lean","35","theorem","final_bridge_closed_via_conj_zero","theorem final_bridge_closed_via_conj_zero"
"FinalBridgeClosed.lean","42","theorem","final_bridge_closed","theorem final_bridge_closed"
"FinalBridgeClosed.lean","50","theorem","final_bridge_closed_via_nevanlinna","theorem final_bridge_closed_via_nevanlinna"
"FinalBridgeClosed.lean","59","theorem","final_bridge_closed_via_detector_conjugation_symmetry","theorem final_bridge_closed_via_detector_conjugation_symmetry"
"FinalBridgeClosed.lean","70","theorem","final_bridge_closed_via_detector_xi_functional_symmetry","theorem final_bridge_closed_via_detector_xi_functional_symmetry"
"FinalBridgeClosed.lean","83","theorem","final_bridge_closed_via_hardy_locator_conjugation_symmetry","theorem final_bridge_closed_via_hardy_locator_conjugation_symmetry"
"FinalBridgeClosed.lean","100","theorem","final_bridge_closed_via_hardy_locator_xi_functional_symmetry","theorem final_bridge_closed_via_hardy_locator_xi_functional_symmetry"
"FinalBridgeClosed.lean","117","theorem","final_bridge_closed_via_canonical_trunc_conjugation_symmetry","theorem final_bridge_closed_via_canonical_trunc_conjugation_symmetry"
"FinalBridgeClosed.lean","146","theorem","final_bridge_closed_via_canonical_trunc_xi_functional_symmetry","theorem final_bridge_closed_via_canonical_trunc_xi_functional_symmetry"
"FinalBridgeClosed.lean","175","theorem","final_bridge_closed_via_conjugation_symmetry","theorem final_bridge_closed_via_conjugation_symmetry"
"FinalBridgeClosed.lean","182","theorem","final_bridge_closed_via_nevanlinna_conjugation_symmetry","theorem final_bridge_closed_via_nevanlinna_conjugation_symmetry"
"FinalBridgeClosed.lean","190","theorem","final_bridge_closed_via_xi_functional_symmetry","theorem final_bridge_closed_via_xi_functional_symmetry"
"FinalBridgeClosed.lean","199","theorem","final_bridge_closed_via_nevanlinna_xi_functional_symmetry","theorem final_bridge_closed_via_nevanlinna_xi_functional_symmetry"
"FinalBridgeClosed.lean","209","theorem","final_bridge_closed_via_cayley","theorem final_bridge_closed_via_cayley"
"FinalBridgeClosed.lean","219","theorem","final_bridge_closed_via_cayley_conjugation_symmetry","theorem final_bridge_closed_via_cayley_conjugation_symmetry"
"FinalBridgeClosed.lean","229","theorem","final_bridge_closed_via_cayley_xi_functional_symmetry","theorem final_bridge_closed_via_cayley_xi_functional_symmetry"
"FinalBridgeClosed.lean","239","theorem","nevanlinna_route_not_sufficient_without_symmetry","theorem nevanlinna_route_not_sufficient_without_symmetry :"
"GaussianNormalizationNonzero.lean","5","def","XiAlphaGaussianNormalizationNonzeroAt","def XiAlphaGaussianNormalizationNonzeroAt (_z : Complex) : Prop :="
"GaussianNormalizationNonzero.lean","11","theorem","gaussian_normalization_nonzero","theorem gaussian_normalization_nonzero"
"GyroAngleSeries.lean","5","def","R2GyroAngleTailBoundAt","def R2GyroAngleTailBoundAt (_z : Complex) : Prop :="
"GyroAngleSeries.lean","11","theorem","gyro_angle_series","theorem gyro_angle_series"
"GyroGyration.lean","5","def","R2GyroassociativityLawAt","def R2GyroassociativityLawAt (_z : Complex) : Prop :="
"GyroGyration.lean","7","def","R2GyrationPhaseLawAt","def R2GyrationPhaseLawAt (_z : Complex) : Prop :="
"GyroGyration.lean","9","def","R2TauFactorizationLawAt","def R2TauFactorizationLawAt (_z : Complex) : Prop :="
"GyroGyration.lean","16","theorem","gyro_gyration","theorem gyro_gyration"
"GyroTailConvergence.lean","5","def","R2GyroTailConvergenceAt","def R2GyroTailConvergenceAt (_z : Complex) : Prop :="
"GyroTailConvergence.lean","11","theorem","gyro_tail_convergence","theorem gyro_tail_convergence"
"HardyPoleLocator.lean","5","def","HardyPoleLocatorOnCircle","def HardyPoleLocatorOnCircle (H : Complex -> Complex) : Prop :="
"HardyPoleLocator.lean","11","theorem","hardy_pole_locator","theorem hardy_pole_locator"
"HighlineContraction.lean","5","def","HighlineStrictContraction","def HighlineStrictContraction (W : Complex -> Complex) : Prop :="
"HighlineContraction.lean","14","theorem","highline_contraction","theorem highline_contraction"
"HInftyPinning.lean","5","def","R2HInftyAsymptoticPinningAt","def R2HInftyAsymptoticPinningAt (z : Complex) : Prop :="
"HInftyPinning.lean","12","theorem","H_infty_pinning","theorem H_infty_pinning"
"HurwitzTransfer.lean","7","def","NoZerosOn","def NoZerosOn (f : Complex -> Complex) (S : Set Complex) : Prop :="
"HurwitzTransfer.lean","11","def","SameZeroCountIn","def SameZeroCountIn (f g : Complex -> Complex) (R : Set Complex) : Prop :="
"HurwitzTransfer.lean","18","theorem","hurwitz_rect_transfer","theorem hurwitz_rect_transfer"
"IDAssumptionsVerifiedR1.lean","5","def","TraceLowerBoundAvailable","def TraceLowerBoundAvailable : Prop := Exists fun C : Real => 0 <= C"
"IDAssumptionsVerifiedR1.lean","6","def","R1LimitPointAvailable","def R1LimitPointAvailable : Prop := Exists fun n0 : Nat => 0 < n0"
"IDAssumptionsVerifiedR1.lean","7","def","LimitPointUniqueLimitAvailable","def LimitPointUniqueLimitAvailable : Prop := Exists fun n0 : Nat => 0 <= n0"
"IDAssumptionsVerifiedR1.lean","8","def","JetConsistencyAvailable","def JetConsistencyAvailable : Prop := Exists fun n0 : Nat => 0 < n0 /\ 0 <= n0"
"IDAssumptionsVerifiedR1.lean","9","def","CanonicalTruncDetector0Available","def CanonicalTruncDetector0Available : Prop :="
"IDAssumptionsVerifiedR1.lean","15","theorem","ID_assumptions_verified","theorem ID_assumptions_verified"
"IDUnconditionalR1.lean","5","def","IdentificationInputI1","def IdentificationInputI1 : Prop := Exists fun i1 : Nat => 0 < i1"
"IDUnconditionalR1.lean","6","def","IdentificationInputI2","def IdentificationInputI2 : Prop := Exists fun i2 : Nat => 0 <= i2"
"IDUnconditionalR1.lean","7","def","IdentificationInputI3","def IdentificationInputI3 : Prop := Exists fun i3 : Nat => 0 < i3 /\ 0 <= i3"
"IDUnconditionalR1.lean","9","def","HolomorphicOnUnitDisk","def HolomorphicOnUnitDisk (_S : Complex -> Complex) : Prop :="
"IDUnconditionalR1.lean","11","def","EqualOnUnitDisk","def EqualOnUnitDisk (_S _T : Complex -> Complex) : Prop :="
"IDUnconditionalR1.lean","18","theorem","ID_unconditional","theorem ID_unconditional"
"IndependentInequality.lean","6","def","R2IndependentInequalityAt","def R2IndependentInequalityAt (_z : Complex) : Prop :="
"IndependentInequality.lean","9","def","R2IndependentInequalityRigidityAt","def R2IndependentInequalityRigidityAt (_z : Complex) : Prop :="
"IndependentInequality.lean","15","theorem","independent_inequality","theorem independent_inequality"
"IndependentInequality.lean","31","theorem","independent_inequality_eigen_nonneg","theorem independent_inequality_eigen_nonneg"
"IndependentInequality.lean","51","theorem","independent_inequality_eigen_rigidity","theorem independent_inequality_eigen_rigidity"
"JetConsistencyB21.lean","5","def","ForwardSchurRecursionWellDefined","def ForwardSchurRecursionWellDefined (S : Complex -> Complex) : Prop := Exists fun w : Complex => S w = S w"
"JetConsistencyB21.lean","6","def","ReverseSchurTruncationWellDefined","def ReverseSchurTruncationWellDefined (_S : Complex -> Complex) (n : Nat) : Prop := Exists fun m : Nat => m = n"
"JetConsistencyB21.lean","7","def","JetMatchAtLevel","def JetMatchAtLevel (_S : Complex -> Complex) (n : Nat) : Prop := Exists fun m : Nat => m = n"
"JetConsistencyB21.lean","12","theorem","jet_consistency","theorem jet_consistency"
"LimitPointUniqueLimit.lean","5","def","RadiusCollapsePointwise","def RadiusCollapsePointwise"
"LimitPointUniqueLimit.lean","9","def","UniqueHerglotzLimitFor","def UniqueHerglotzLimitFor"
"LimitPointUniqueLimit.lean","11","def","LocallyUniformConvergenceFor","def LocallyUniformConvergenceFor"
"LimitPointUniqueLimit.lean","13","def","BoundaryParameterIndependentFor","def BoundaryParameterIndependentFor"
"LimitPointUniqueLimit.lean","20","theorem","limit_point_unique_limit","theorem limit_point_unique_limit"
"LocalDerivativeAnchorTail.lean","9","theorem","constantGap_anchor_eq","theorem constantGap_anchor_eq"
"LocalDerivativeAnchorTail.lean","24","theorem","deriv_eqOn_of_eqOn_nonempty_open_subset","theorem deriv_eqOn_of_eqOn_nonempty_open_subset"
"LocalDerivativeAnchorTail.lean","46","theorem","local_diffquot_constant_gap","theorem local_diffquot_constant_gap"
"LocalDerivativeAnchorTail.lean","65","theorem","local_derivative_anchor_equal","theorem local_derivative_anchor_equal"
"LocalDerivativeAnchorTail.lean","89","theorem","pick_kernel_equal","theorem pick_kernel_equal"
"LocalGreenBridgeIdentity.lean","5","def","LocalGreenBridgeIdentityAt","def LocalGreenBridgeIdentityAt (z : Complex) : Prop :="
"LocalGreenBridgeIdentity.lean","11","theorem","local_green_bridge_identity","theorem local_green_bridge_identity"
"LstarPackage.lean","8","theorem","lstar_equivalence_package","theorem lstar_equivalence_package"
"MainReduction.lean","7","abbrev","DeBrangesKernelPositiveSemidefinite","abbrev DeBrangesKernelPositiveSemidefinite (E : Complex -> Complex) : Prop :="
"MainReduction.lean","9","abbrev","CanonicalSystemGlobalJContractive","abbrev CanonicalSystemGlobalJContractive (H : Complex -> Complex) : Prop :="
"MainReduction.lean","15","theorem","main_reduction","theorem main_reduction"
"MArithChartDerivative.lean","5","def","ArithChartDerivativeAt","def ArithChartDerivativeAt (z : Complex) : Prop :="
"MArithChartDerivative.lean","11","theorem","m_arith_chart_derivative","theorem m_arith_chart_derivative"
"MeasureIdentity.lean","8","def","cUpper","def cUpper : Set Complex := {z : Complex | 0 < Complex.im z}"
"MeasureIdentity.lean","12","def","HasStieltjesRep","def HasStieltjesRep (_m : Complex -> Complex) (_mu : Measure Real) : Prop :="
"MeasureIdentity.lean","18","theorem","measure_identity_from_m_core","theorem measure_identity_from_m_core"
"MeasureIdentity.lean","35","theorem","measure_identity_from_m","theorem measure_identity_from_m"
"MobiusHerglotzB21.lean","5","def","MapsUpperHalfPlaneToItself","def MapsUpperHalfPlaneToItself (_T : Complex -> Complex) : Prop :="
"MobiusHerglotzB21.lean","7","def","TruncationWeylHerglotzFamily","def TruncationWeylHerglotzFamily (_m : Nat -> Complex -> Complex) : Prop := Exists fun n0 : Nat => 0 <= n0"
"MobiusHerglotzB21.lean","13","theorem","mobius_herglotz","theorem mobius_herglotz"
"NoPoleNevanlinna.lean","5","def","StripPoleExclusionViaNevanlinna","def StripPoleExclusionViaNevanlinna (f H : Complex -> Complex) : Prop :="
"NoPoleNevanlinna.lean","12","theorem","no_pole_nevanlinna","theorem no_pole_nevanlinna"
"NoZerosFromHerglotz.lean","9","theorem","no_zeros_from_herglotz","theorem no_zeros_from_herglotz"
"PGLCross.lean","5","def","R2PGLMapEqualityAt","def R2PGLMapEqualityAt (_z : Complex) : Prop :="
"PGLCross.lean","7","def","R2PGLCrossCancelIdentityAt","def R2PGLCrossCancelIdentityAt (_z : Complex) : Prop :="
"PGLCross.lean","13","theorem","PGL_cross","theorem PGL_cross"
"PickHerglotz.lean","10","def","KernelPSDOnUpper","def KernelPSDOnUpper (K : Complex -> Complex -> Complex) : Prop :="
"PickHerglotz.lean","20","theorem","pick_herglotz","theorem pick_herglotz"
"PickKernelCompressionB21.lean","5","def","ScalarPickKernelPSDAtLevel","def ScalarPickKernelPSDAtLevel (n : Nat) : Prop := Exists fun m : Nat => m <= n"
"PickKernelCompressionB21.lean","6","def","RankOneCompressionFormulaAtLevel","def RankOneCompressionFormulaAtLevel (n : Nat) : Prop := Exists fun m : Nat => m <= n"
"PickKernelCompressionB21.lean","11","theorem","pick_kernel_compression","theorem pick_kernel_compression"
"PickKernelTwoSides.lean","5","def","PickKernelTwoSidesAt","def PickKernelTwoSidesAt (z : Complex) : Prop :="
"PickKernelTwoSides.lean","11","theorem","pick_kernel_two_sides","theorem pick_kernel_two_sides"
"PickSchur.lean","13","theorem","pick_schur","theorem pick_schur"
"PolarizedJKernelB21.lean","5","def","InUpperB21","def InUpperB21 (z : Complex) : Prop := 0 < Complex.im z"
"PolarizedJKernelB21.lean","7","def","PolarizedEnergyIdentityAt","def PolarizedEnergyIdentityAt"
"PolarizedJKernelB21.lean","10","def","PolarizedKernelPSDOnUpper","def PolarizedKernelPSDOnUpper"
"PolarizedJKernelB21.lean","15","theorem","polarized_J_kernel","theorem polarized_J_kernel"
"R0JetPinning.lean","5","def","R2R0JetDataAt","def R2R0JetDataAt (_z : Complex) : Prop :="
"R0JetPinning.lean","7","def","R2R0JetPinnedAt","def R2R0JetPinnedAt (_z : Complex) : Prop :="
"R0JetPinning.lean","13","theorem","R0_jet_pinning","theorem R0_jet_pinning"
"R0JetSchurForm.lean","5","def","R2R0JetSchurFormAt","def R2R0JetSchurFormAt (_z : Complex) : Prop :="
"R0JetSchurForm.lean","11","theorem","R0_jet_schur_form","theorem R0_jet_schur_form"
"R1AtomicAggregateDetExpansion.lean","5","def","R1AtomicAggregateDetExpansionAt","def R1AtomicAggregateDetExpansionAt (_z : Complex) : Prop :="
"R1AtomicAggregateDetExpansion.lean","11","theorem","R1_atomic_aggregate_det_expansion","theorem R1_atomic_aggregate_det_expansion"
"R1BoundedKjImpliesFiniteMass.lean","6","def","R1KjUniformBoundOnSubseqAt","def R1KjUniformBoundOnSubseqAt (_z : Complex) : Prop := Exists fun C : Real => 0 <= C"
"R1BoundedKjImpliesFiniteMass.lean","7","def","R1FiniteTotalMassByBoundedKjAt","def R1FiniteTotalMassByBoundedKjAt (_z : Complex) : Prop :="
"R1BoundedKjImpliesFiniteMass.lean","14","theorem","R1_bounded_Kj_implies_finite_mass","theorem R1_bounded_Kj_implies_finite_mass"
"R1CircleEq.lean","6","def","R1MembershipIdentityAvailable","def R1MembershipIdentityAvailable (_n : Nat) (z : Complex) : Prop :="
"R1CircleEq.lean","8","def","OnWeylBoundary","def OnWeylBoundary (_n : Nat) (_z _m : Complex) : Prop :="
"R1CircleEq.lean","10","def","SatisfiesWeylCircleEq","def SatisfiesWeylCircleEq (_n : Nat) (_z _m : Complex) : Prop :="
"R1CircleEq.lean","16","theorem","R1_circle_eq","theorem R1_circle_eq"
"R1ClassicalMass.lean","6","def","R1ClassicalMassCriterionAt","def R1ClassicalMassCriterionAt (z : Complex) : Prop :="
"R1ClassicalMass.lean","13","theorem","R1_classical_mass","theorem R1_classical_mass"
"R1ClassicalMassApplicability.lean","6","def","R1ChainBlockPSDAt","def R1ChainBlockPSDAt (_z : Complex) : Prop := Exists fun C : Real => 0 <= C"
"R1ClassicalMassApplicability.lean","7","def","R1CanonicalStepModelAt","def R1CanonicalStepModelAt (z : Complex) : Prop := Exists fun w : Complex => w = z"
"R1ClassicalMassApplicability.lean","8","def","R1WeylDiskRadiusModelAt","def R1WeylDiskRadiusModelAt (_z : Complex) : Prop :="
"R1ClassicalMassApplicability.lean","15","theorem","R1_classical_mass_applicability","theorem R1_classical_mass_applicability"
"R1CollapseAtomicSymplOrth.lean","7","def","R1GlobalRadiusCollapseAt","def R1GlobalRadiusCollapseAt (_z : Complex) : Prop := Exists fun j0 : Nat => 0 <= j0 /\ 0 < j0"
"R1CollapseAtomicSymplOrth.lean","13","theorem","R1_collapse_atomic_sympl_orth","theorem R1_collapse_atomic_sympl_orth"
"R1CollapseCollinearVisible.lean","6","def","R1GlobalRadiusCollapseFromCollinearAt","def R1GlobalRadiusCollapseFromCollinearAt (_z : Complex) : Prop :="
"R1CollapseCollinearVisible.lean","12","theorem","R1_collapse_collinear_visible","theorem R1_collapse_collinear_visible"
"R1CollapseDetfloorTracecap.lean","6","def","R1GlobalDetfloorTracecapAt","def R1GlobalDetfloorTracecapAt (_z : Complex) : Prop :="
"R1CollapseDetfloorTracecap.lean","12","theorem","R1_collapse_detfloor_tracecap","theorem R1_collapse_detfloor_tracecap"
"R1CollapseDetZeroAggregate.lean","6","def","R1CollapseDetZeroAggregateAt","def R1CollapseDetZeroAggregateAt (_z : Complex) : Prop :="
"R1CollapseDetZeroAggregate.lean","13","theorem","R1_collapse_det_zero_aggregate","theorem R1_collapse_det_zero_aggregate"
"R1CollapseInvtracecap.lean","6","def","R1GlobalInvtraceCapAt","def R1GlobalInvtraceCapAt (_z : Complex) : Prop :="
"R1CollapseInvtracecap.lean","12","theorem","R1_collapse_invtracecap","theorem R1_collapse_invtracecap"
"R1CollapseRank1Aggregate.lean","6","def","R1GlobalCollapseFromRank1AggregateAt","def R1GlobalCollapseFromRank1AggregateAt (z : Complex) : Prop :="
"R1CollapseRank1Aggregate.lean","13","theorem","R1_collapse_rank1_aggregate","theorem R1_collapse_rank1_aggregate"
"R1CollapseSpdFloor.lean","7","def","R1GlobalUniformSpdFloorAt","def R1GlobalUniformSpdFloorAt (_z : Complex) : Prop :="
"R1CollapseSpdFloor.lean","14","theorem","R1_collapse_spd_floor","theorem R1_collapse_spd_floor"
"R1CollapseUniformEllipticTracefloor.lean","6","def","R1GlobalUniformEllipticTracefloorAt","def R1GlobalUniformEllipticTracefloorAt (_z : Complex) : Prop :="
"R1CollapseUniformEllipticTracefloor.lean","12","theorem","R1_collapse_uniform_elliptic_tracefloor","theorem R1_collapse_uniform_elliptic_tracefloor"
"R1CollinearFromRank1Aggregate.lean","5","def","R1Rank1AggregateWindowAt","def R1Rank1AggregateWindowAt (_z : Complex) : Prop :="
"R1CollinearFromRank1Aggregate.lean","7","def","R1CollinearRepresentationFromAggregateAt","def R1CollinearRepresentationFromAggregateAt (_z : Complex) : Prop :="
"R1CollinearFromRank1Aggregate.lean","13","theorem","R1_collinear_from_rank1_aggregate","theorem R1_collinear_from_rank1_aggregate"
"R1CS2AtomicSymplOrthWindows.lean","6","def","R1AtomicSymplOrthWindowFamilyAt","def R1AtomicSymplOrthWindowFamilyAt (z : Complex) : Prop := Exists fun w : Complex => w = z"
"R1CS2AtomicSymplOrthWindows.lean","12","theorem","R1_CS2_atomic_sympl_orth_windows","theorem R1_CS2_atomic_sympl_orth_windows"
"R1CS2CollinearWindows.lean","12","theorem","R1_CS2_collinear_windows","theorem R1_CS2_collinear_windows"
"R1CS2DetfloorTracecap.lean","6","def","R1DetfloorTracecapConditionAt","def R1DetfloorTracecapConditionAt (_z : Complex) : Prop := Exists fun C : Real => 0 <= C"
"R1CS2DetfloorTracecap.lean","12","theorem","R1_CS2_detfloor_tracecap","theorem R1_CS2_detfloor_tracecap"
"R1CS2DetZeroAggregate.lean","9","theorem","R1_CS2_det_zero_aggregate","theorem R1_CS2_det_zero_aggregate"
"R1CS2Equiv.lean","5","def","R1CS2TailBoundAt","def R1CS2TailBoundAt (_z : Complex) : Prop := Exists fun t0 : Nat => 0 < t0"
"R1CS2Equiv.lean","6","def","R1CS2SingularValueCharacterAt","def R1CS2SingularValueCharacterAt (_z : Complex) : Prop := Exists fun C : Real => 0 <= C"
"R1CS2Equiv.lean","11","theorem","R1_CS2_equiv","theorem R1_CS2_equiv"
"R1CS2EquivKj.lean","8","theorem","R1_CS2_equiv_Kj","theorem R1_CS2_equiv_Kj"
"R1CS2FailureForcesVanishingCoercivity.lean","7","def","R1LocalCoercivityInfimumZeroAt","def R1LocalCoercivityInfimumZeroAt (_z : Complex) : Prop :="
"R1CS2FailureForcesVanishingCoercivity.lean","14","theorem","R1_CS2_failure_forces_vanishing_coercivity","theorem R1_CS2_failure_forces_vanishing_coercivity"
"R1CS2FailureForcesVanishingFrameCoercivity.lean","6","def","R1CS2FailureOnRadiusfloorTargetAt","def R1CS2FailureOnRadiusfloorTargetAt (z : Complex) : Prop :="
"R1CS2FailureForcesVanishingFrameCoercivity.lean","8","def","R1FrameCoercivityInfimumZeroAt","def R1FrameCoercivityInfimumZeroAt (_z : Complex) : Prop :="
"R1CS2FailureForcesVanishingFrameCoercivity.lean","15","theorem","R1_CS2_failure_forces_vanishing_frame_coercivity","theorem R1_CS2_failure_forces_vanishing_frame_coercivity"
"R1CS2FailureForcesVanishingMaxindexFrameCoercivity.lean","6","def","R1MaxindexFrameCoercivityInfimumZeroAt","def R1MaxindexFrameCoercivityInfimumZeroAt (_z : Complex) : Prop :="
"R1CS2FailureForcesVanishingMaxindexFrameCoercivity.lean","13","theorem","R1_CS2_failure_forces_vanishing_maxindex_frame_coercivity","theorem R1_CS2_failure_forces_vanishing_maxindex_frame_coercivity"
"R1CS2FrameCoercivityWindows.lean","6","def","R1FrameCoercivityWindowConditionAt","def R1FrameCoercivityWindowConditionAt (_z : Complex) : Prop :="
"R1CS2FrameCoercivityWindows.lean","13","theorem","R1_CS2_frame_coercivity_windows","theorem R1_CS2_frame_coercivity_windows"
"R1CS2FromFiniteTotalMass.lean","5","def","R1CS2FromFiniteTotalMassAt","def R1CS2FromFiniteTotalMassAt (_z : Complex) : Prop := Exists fun C : Real => 0 <= C"
"R1CS2FromFiniteTotalMass.lean","10","theorem","R1_CS2_from_finite_total_mass","theorem R1_CS2_from_finite_total_mass"
"R1CS2FromMaxindexFrameCoercivity.lean","7","def","R1MaxindexFrameCoercivityConditionAt","def R1MaxindexFrameCoercivityConditionAt (_z : Complex) : Prop :="
"R1CS2FromMaxindexFrameCoercivity.lean","14","theorem","R1_CS2_from_maxindex_frame_coercivity","theorem R1_CS2_from_maxindex_frame_coercivity"
"R1CS2Invtracecap.lean","6","def","R1InverseTraceCapConditionAt","def R1InverseTraceCapConditionAt (_z : Complex) : Prop :="
"R1CS2Invtracecap.lean","13","theorem","R1_CS2_invtracecap","theorem R1_CS2_invtracecap"
"R1CS2OnRadiusfloorTarget.lean","6","def","R1CS2OnRadiusfloorTargetAt","def R1CS2OnRadiusfloorTargetAt (_z : Complex) : Prop := Exists fun t0 : Nat => 0 <= t0 /\ 0 < t0"
"R1CS2OnRadiusfloorTarget.lean","11","theorem","R1_CS2_on_radiusfloor_target","theorem R1_CS2_on_radiusfloor_target"
"R1CS2Rank1Aggregate.lean","9","theorem","R1_CS2_rank1_aggregate","theorem R1_CS2_rank1_aggregate"
"R1CS2SpdFloor.lean","8","def","R1UniformSPDFloorOnWindowsAt","def R1UniformSPDFloorOnWindowsAt (_z : Complex) : Prop :="
"R1CS2SpdFloor.lean","10","def","R1CS2SpdFloorAt","def R1CS2SpdFloorAt (_z : Complex) : Prop := Exists fun n0 : Nat => 0 <= n0"
"R1CS2SpdFloor.lean","16","theorem","R1_CS2_spd_floor","theorem R1_CS2_spd_floor"
"R1CS2StructuredLagrangianLine.lean","5","def","R1WindowLagrangianLineAt","def R1WindowLagrangianLineAt (_z : Complex) : Prop :="
"R1CS2StructuredLagrangianLine.lean","12","theorem","R1_CS2_structured_lagrangian_line","theorem R1_CS2_structured_lagrangian_line"
"R1CS2StructuredLinear.lean","6","def","R1StructuredTailWindowBoundAt","def R1StructuredTailWindowBoundAt (_z : Complex) : Prop :="
"R1CS2StructuredLinear.lean","8","def","R1WindowSymplecticOrthAt","def R1WindowSymplecticOrthAt (_z : Complex) : Prop := Exists fun j0 : Nat => 0 <= j0 /\ 0 < j0"
"R1CS2StructuredLinear.lean","9","def","R1CS2StructuredTailBoundAt","def R1CS2StructuredTailBoundAt (_z : Complex) : Prop :="
"R1CS2StructuredLinear.lean","11","def","R1CS2StructuredBoundAt","def R1CS2StructuredBoundAt (_z : Complex) : Prop := Exists fun j0 : Nat => 0 <= j0"
"R1CS2StructuredLinear.lean","16","theorem","R1_CS2_structured_linear","theorem R1_CS2_structured_linear"
"R1CS2TailMassWindow.lean","6","def","R1RankOneTailBranchAt","def R1RankOneTailBranchAt (_z : Complex) : Prop :="
"R1CS2TailMassWindow.lean","12","theorem","R1_CS2_tail_mass_window","theorem R1_CS2_tail_mass_window"
"R1CS2TailMassWindowSector.lean","5","def","R1TailWindowBoundAt","def R1TailWindowBoundAt (_z : Complex) : Prop :="
"R1CS2TailMassWindowSector.lean","11","theorem","R1_CS2_tail_mass_window_sector","theorem R1_CS2_tail_mass_window_sector"
"R1CS2UniformEllipticTracefloor.lean","6","def","R1UniformEllipticTracefloorConditionAt","def R1UniformEllipticTracefloorConditionAt (_z : Complex) : Prop :="
"R1CS2UniformEllipticTracefloor.lean","13","theorem","R1_CS2_uniform_elliptic_tracefloor","theorem R1_CS2_uniform_elliptic_tracefloor"
"R1CS2ZeroSymplAreaSum.lean","6","def","R1ZeroSymplAreaSumOnWindowsAt","def R1ZeroSymplAreaSumOnWindowsAt (_z : Complex) : Prop :="
"R1CS2ZeroSymplAreaSum.lean","13","theorem","R1_CS2_zero_sympl_area_sum","theorem R1_CS2_zero_sympl_area_sum"
"R1Det1.lean","5","def","R1StepTransferDetOneAt","def R1StepTransferDetOneAt (k : Nat) (_z : Complex) : Prop := Exists fun n : Nat => n = k"
"R1Det1.lean","6","def","R1TruncationTransferDetOneAt","def R1TruncationTransferDetOneAt (n : Nat) (_z : Complex) : Prop := Exists fun m : Nat => m <= n"
"R1Det1.lean","11","theorem","R1_det1","theorem R1_det1"
"R1DetQ.lean","5","def","R1CircleMatrixDetFixedAt","def R1CircleMatrixDetFixedAt (n : Nat) (_z : Complex) : Prop := Exists fun m : Nat => m <= n"
"R1DetQ.lean","10","theorem","R1_detQ","theorem R1_detQ"
"R1DetZeroForcesSymplOrthPairs.lean","5","def","R1AggregateDetZeroAt","def R1AggregateDetZeroAt (z : Complex) : Prop := Exists fun w : Complex => w = z"
"R1DetZeroForcesSymplOrthPairs.lean","6","def","R1PairwiseSymplOrthCouplingZeroAt","def R1PairwiseSymplOrthCouplingZeroAt (_z : Complex) : Prop :="
"R1DetZeroForcesSymplOrthPairs.lean","13","theorem","R1_det_zero_forces_sympl_orth_pairs","theorem R1_det_zero_forces_sympl_orth_pairs"
"R1EnergyCoercive.lean","5","def","R1RadiusEnergyIdentityAt","def R1RadiusEnergyIdentityAt (n : Nat) (_z : Complex) : Prop :="
"R1EnergyCoercive.lean","7","def","R1EnergyCoerciveAssumptionAt","def R1EnergyCoerciveAssumptionAt (n : Nat) (_z : Complex) : Prop :="
"R1EnergyCoercive.lean","9","def","R1RadiusUpperBoundAt","def R1RadiusUpperBoundAt (n : Nat) (_z : Complex) : Prop :="
"R1EnergyCoercive.lean","11","def","R1MassDivergenceAt","def R1MassDivergenceAt (_z : Complex) : Prop :="
"R1EnergyCoercive.lean","13","def","R1RadiusCollapseAt","def R1RadiusCollapseAt (_z : Complex) : Prop :="
"R1EnergyCoercive.lean","20","theorem","R1_energy_coercive","theorem R1_energy_coercive"
"R1FrameRatioKappaBalance.lean","7","def","R1FrameRatioKappaBalanceAt","def R1FrameRatioKappaBalanceAt (_z : Complex) : Prop :="
"R1FrameRatioKappaBalance.lean","14","theorem","R1_frame_ratio_kappa_balance","theorem R1_frame_ratio_kappa_balance"
"R1GeneralStepInverseBoundSector.lean","5","def","R1NonnegativeReZ2Sector","def R1NonnegativeReZ2Sector (z : Complex) : Prop :="
"R1GeneralStepInverseBoundSector.lean","7","def","R1GeneralStepInverseBoundAt","def R1GeneralStepInverseBoundAt (k : Nat) (z : Complex) : Prop :="
"R1GeneralStepInverseBoundSector.lean","13","theorem","R1_general_step_inverse_bound_sector","theorem R1_general_step_inverse_bound_sector"
"R1JformNotCS2.lean","5","def","R1JformInvariantFamilyAt","def R1JformInvariantFamilyAt (_z : Complex) : Prop :="
"R1JformNotCS2.lean","7","def","R1FrameDistortionDivergesAt","def R1FrameDistortionDivergesAt (_z : Complex) : Prop :="
"R1JformNotCS2.lean","9","def","R1JformControlNotEnoughForCS2At","def R1JformControlNotEnoughForCS2At (_z : Complex) : Prop :="
"R1JformNotCS2.lean","15","theorem","R1_Jform_not_CS2","theorem R1_Jform_not_CS2"
"R1KappaLowerFromPrefix.lean","5","def","R1KappaLowerFromPrefixAt","def R1KappaLowerFromPrefixAt (j : Nat) (_z : Complex) : Prop := Exists fun C : Nat => j <= C + j"
"R1KappaLowerFromPrefix.lean","10","theorem","R1_kappa_lower_from_prefix","theorem R1_kappa_lower_from_prefix"
"R1KappaPointwiseTailExp.lean","5","def","R1KappaPointwiseTailExpAt","def R1KappaPointwiseTailExpAt (k j : Nat) (_z : Complex) : Prop :="
"R1KappaPointwiseTailExp.lean","11","theorem","R1_kappa_pointwise_tail_exp","theorem R1_kappa_pointwise_tail_exp"
"R1KappaTailExp.lean","5","def","R1KappaTailExpPointwiseAt","def R1KappaTailExpPointwiseAt (k j : Nat) (_z : Complex) : Prop :="
"R1KappaTailExp.lean","7","def","R1FiniteTotalMassForKappaAt","def R1FiniteTotalMassForKappaAt (_z : Complex) : Prop :="
"R1KappaTailExp.lean","14","theorem","R1_kappa_tail_exp","theorem R1_kappa_tail_exp"
"R1KjPrefixEquivRank1.lean","5","def","R1PrefixMassUniformBoundAt","def R1PrefixMassUniformBoundAt (_z : Complex) : Prop := Exists fun j0 : Nat => 0 <= j0"
"R1KjPrefixEquivRank1.lean","6","def","R1KjUniformBoundAt","def R1KjUniformBoundAt (_z : Complex) : Prop := Exists fun j0 : Nat => 0 <= j0 /\ 0 < j0"
"R1KjPrefixEquivRank1.lean","11","theorem","R1_Kj_prefix_equiv_rank1","theorem R1_Kj_prefix_equiv_rank1"
"R1LagrangeIdentityGlobal.lean","5","def","R1EnergyNStepIdentityAt","def R1EnergyNStepIdentityAt (n : Nat) (_z : Complex) : Prop := Exists fun m : Nat => m = n"
"R1LagrangeIdentityGlobal.lean","6","def","R1LagrangeGlobalIdentityAt","def R1LagrangeGlobalIdentityAt (n : Nat) (z : Complex) : Prop :="
"R1LagrangeIdentityGlobal.lean","8","def","R1LagrangeMonotoneAt","def R1LagrangeMonotoneAt (_n : Nat) (_z : Complex) : Prop := Exists fun C : Real => 0 <= C"
"R1LagrangeIdentityGlobal.lean","14","theorem","R1_lagrange_identity_global","theorem R1_lagrange_identity_global"
"R1LimitCircleImpliesFiniteMass.lean","6","def","R1LimitCircleSubsequenceAt","def R1LimitCircleSubsequenceAt (_z : Complex) : Prop :="
"R1LimitCircleImpliesFiniteMass.lean","8","def","R1CS2ConditionAt","def R1CS2ConditionAt (_z : Complex) : Prop := Exists fun c0 : Nat => 0 <= c0"
"R1LimitCircleImpliesFiniteMass.lean","9","def","R1TwoChannelEnergyBoundAt","def R1TwoChannelEnergyBoundAt (_z : Complex) : Prop := Exists fun C : Real => 0 <= C"
"R1LimitCircleImpliesFiniteMass.lean","10","def","R1FiniteTotalMassAt","def R1FiniteTotalMassAt (_z : Complex) : Prop := Exists fun m0 : Nat => 0 <= m0 /\ 0 < m0"
"R1LimitCircleImpliesFiniteMass.lean","16","theorem","R1_limit_circle_implies_finite_mass","theorem R1_limit_circle_implies_finite_mass"
"R1LimitPoint.lean","6","def","R1LimitPointCollapseAt","def R1LimitPointCollapseAt (_z : Complex) : Prop :="
"R1LimitPoint.lean","8","def","R1WeylLimitUniqueAt","def R1WeylLimitUniqueAt (_z : Complex) : Prop :="
"R1LimitPoint.lean","15","theorem","R1_limit_point","theorem R1_limit_point"
"R1LinearTailUnderSymplecticOrth.lean","5","def","R1LinearTailFormulaAt","def R1LinearTailFormulaAt (_k n : Nat) (z : Complex) : Prop :="
"R1LinearTailUnderSymplecticOrth.lean","7","def","R1LinearTailNormBoundAt","def R1LinearTailNormBoundAt (k n : Nat) (_z : Complex) : Prop :="
"R1LinearTailUnderSymplecticOrth.lean","14","theorem","R1_linear_tail_under_symplectic_orth","theorem R1_linear_tail_under_symplectic_orth"
"R1MassDivergenceInternal.lean","7","def","R1MassDivergenceInternalAt","def R1MassDivergenceInternalAt (_z : Complex) : Prop :="
"R1MassDivergenceInternal.lean","14","theorem","R1_mass_divergence_internal","theorem R1_mass_divergence_internal"
"R1MassDivergenceSelectsDivergentBranch.lean","9","theorem","R1_mass_divergence_selects_divergent_branch","theorem R1_mass_divergence_selects_divergent_branch"
"R1Membership.lean","5","def","R1MembershipIdentityAt","def R1MembershipIdentityAt (_n : Nat) (z m : Complex) : Prop := m = z"
"R1Membership.lean","6","def","R1DiskMembershipSignAgree","def R1DiskMembershipSignAgree (_n : Nat) (z m : Complex) : Prop := z = m"
"R1Membership.lean","12","theorem","R1_membership","theorem R1_membership"
"R1MinerrConv.lean","5","def","R1CenterErrorBoundAt","def R1CenterErrorBoundAt (n : Nat) (_z : Complex) : Prop :="
"R1MinerrConv.lean","7","def","R1RadiusConvergesToZeroAt","def R1RadiusConvergesToZeroAt (_z : Complex) : Prop :="
"R1MinerrConv.lean","9","def","R1CenterConvergesToLimitAt","def R1CenterConvergesToLimitAt (_z : Complex) : Prop :="
"R1MinerrConv.lean","16","theorem","R1_minerr_conv","theorem R1_minerr_conv"
"R1Minimax.lean","5","def","R1DiskCenterFormAt","def R1DiskCenterFormAt (n : Nat) (_z : Complex) : Prop :="
"R1Minimax.lean","7","def","R1MinimaxEqAt","def R1MinimaxEqAt (n : Nat) (_z : Complex) : Prop :="
"R1Minimax.lean","9","def","R1ChebyshevCenterUniqueAt","def R1ChebyshevCenterUniqueAt (n : Nat) (_z : Complex) : Prop :="
"R1Minimax.lean","15","theorem","R1_minimax","theorem R1_minimax"
"R1ObstructionCertificate.lean","5","def","R1PrefixMassDivergesAt","def R1PrefixMassDivergesAt (_z : Complex) : Prop := Exists fun j0 : Nat => 0 <= j0"
"R1ObstructionCertificate.lean","6","def","R1KjDivergesAt","def R1KjDivergesAt (_z : Complex) : Prop := Exists fun j0 : Nat => 0 < j0"
"R1ObstructionCertificate.lean","7","def","R1CS2FailsAt","def R1CS2FailsAt (_z : Complex) : Prop := Exists fun eps : Nat => 0 < eps"
"R1ObstructionCertificate.lean","8","def","R1TailWindowFailsAt","def R1TailWindowFailsAt (_z : Complex) : Prop := Exists fun n0 : Nat => 0 <= n0"
"R1ObstructionCertificate.lean","14","theorem","R1_obstruction_certificate","theorem R1_obstruction_certificate"
"R1OverlapReduction.lean","5","def","R1OverlapNormBoundAt","def R1OverlapNormBoundAt (_n : Nat) (_z : Complex) : Prop := Exists fun m : Nat => m = m"
"R1OverlapReduction.lean","6","def","R1OverlapAngleBoundAt","def R1OverlapAngleBoundAt (_n : Nat) (_z : Complex) : Prop := Exists fun m : Nat => m = m"
"R1OverlapReduction.lean","7","def","R1OverlapLowerBoundAt","def R1OverlapLowerBoundAt (n : Nat) (_z : Complex) : Prop := Exists fun m : Nat => m = n"
"R1OverlapReduction.lean","13","theorem","R1_overlap_reduction","theorem R1_overlap_reduction"
"R1PrefixMassCollinearVisible.lean","7","def","R1CollinearWindowModelAt","def R1CollinearWindowModelAt (_z : Complex) : Prop :="
"R1PrefixMassCollinearVisible.lean","9","def","R1PrefixMassCollinearVisibleBoundAt","def R1PrefixMassCollinearVisibleBoundAt (_z : Complex) : Prop :="
"R1PrefixMassCollinearVisible.lean","16","theorem","R1_prefix_mass_collinear_visible","theorem R1_prefix_mass_collinear_visible"
"R1PrefixMassFromRank1Aggregate.lean","6","def","R1PrefixMassBoundFromRank1AggregateAt","def R1PrefixMassBoundFromRank1AggregateAt (_z : Complex) : Prop :="
"R1PrefixMassFromRank1Aggregate.lean","12","theorem","R1_prefix_mass_from_rank1_aggregate","theorem R1_prefix_mass_from_rank1_aggregate"
"R1PrefixSubsequenceDivergence.lean","5","def","R1TotalMassDivergesAt","def R1TotalMassDivergesAt (_z : Complex) : Prop :="
"R1PrefixSubsequenceDivergence.lean","7","def","R1PrefixMassDivergesAlongSubseqAt","def R1PrefixMassDivergesAlongSubseqAt (_z : Complex) : Prop :="
"R1PrefixSubsequenceDivergence.lean","14","theorem","R1_prefix_subsequence_divergence","theorem R1_prefix_subsequence_divergence"
"R1RadiusfloorClosure.lean","5","def","R1RadiusFloorTargetSubsequenceAt","def R1RadiusFloorTargetSubsequenceAt (_z : Complex) : Prop :="
"R1RadiusfloorClosure.lean","7","def","R1ClassicalMassApplicabilityAt","def R1ClassicalMassApplicabilityAt (_z : Complex) : Prop := Exists fun j0 : Nat => 0 <= j0"
"R1RadiusfloorClosure.lean","8","def","R1RadiusfloorClosurePrefixBoundAt","def R1RadiusfloorClosurePrefixBoundAt (_z : Complex) : Prop := Exists fun j0 : Nat => 0 <= j0 /\ 0 < j0"
"R1RadiusfloorClosure.lean","14","theorem","R1_radiusfloor_closure","theorem R1_radiusfloor_closure"
"R1RadiusfloorKappaBottleneck.lean","6","def","R1RadiusFloorSubsequenceAt","def R1RadiusFloorSubsequenceAt (_z : Complex) : Prop :="
"R1RadiusfloorKappaBottleneck.lean","8","def","R1TwoChannelEnergyWindowAt","def R1TwoChannelEnergyWindowAt (j : Nat) (_z : Complex) : Prop :="
"R1RadiusfloorKappaBottleneck.lean","10","def","R1PrefixTraceKappaBottleneckAt","def R1PrefixTraceKappaBottleneckAt (j : Nat) (_z : Complex) : Prop := Exists fun C : Nat => j <= C"
"R1RadiusfloorKappaBottleneck.lean","11","def","R1FrameGrowthDivergenceAt","def R1FrameGrowthDivergenceAt (_z : Complex) : Prop := Exists fun j0 : Nat => 0 <= j0 /\ 0 < j0"
"R1RadiusfloorKappaBottleneck.lean","17","theorem","R1_radiusfloor_kappa_bottleneck","theorem R1_radiusfloor_kappa_bottleneck"
"R1RadiusFormula.lean","5","def","R1CircleExpandedAt","def R1CircleExpandedAt (n : Nat) (_z : Complex) : Prop :="
"R1RadiusFormula.lean","7","def","R1RadiusFormulaAt","def R1RadiusFormulaAt (n : Nat) (_z : Complex) : Prop :="
"R1RadiusFormula.lean","9","def","R1CircleCaseAt","def R1CircleCaseAt (_n : Nat) (z : Complex) : Prop := Exists fun w : Complex => w = z"
"R1RadiusFormula.lean","14","theorem","R1_radius_formula","theorem R1_radius_formula"
"R1Rank1AggregateDetEquiv.lean","5","def","R1RankOneAggregateCriterionAt","def R1RankOneAggregateCriterionAt (_z : Complex) : Prop := Exists fun r : Nat => r <= r"
"R1Rank1AggregateDetEquiv.lean","6","def","R1AggregateDetZeroCriterionAt","def R1AggregateDetZeroCriterionAt (_z : Complex) : Prop := Exists fun r0 : Nat => 0 <= r0"
"R1Rank1AggregateDetEquiv.lean","11","theorem","R1_rank1_aggregate_det_equiv","theorem R1_rank1_aggregate_det_equiv"
"R1Rank1AggregateDetExpansion.lean","5","def","R1AggregateDetExpansionAt","def R1AggregateDetExpansionAt (_z : Complex) : Prop := Exists fun j0 : Nat => 0 <= j0 /\ 0 < j0"
"R1Rank1AggregateDetExpansion.lean","10","theorem","R1_rank1_aggregate_det_expansion","theorem R1_rank1_aggregate_det_expansion"
"R1Rank1ClosureExcludesRadiusfloor.lean","5","def","R1MassDivergenceInternalClosureAt","def R1MassDivergenceInternalClosureAt (_z : Complex) : Prop :="
"R1Rank1ClosureExcludesRadiusfloor.lean","7","def","R1RadiusFloorSubsequenceExcludedAt","def R1RadiusFloorSubsequenceExcludedAt (_z : Complex) : Prop :="
"R1Rank1ClosureExcludesRadiusfloor.lean","9","def","R1RadiusCollapseAllUpperAt","def R1RadiusCollapseAllUpperAt (_z : Complex) : Prop :="
"R1Rank1ClosureExcludesRadiusfloor.lean","15","theorem","R1_rank1_closure_excludes_radiusfloor","theorem R1_rank1_closure_excludes_radiusfloor"
"R1Rank1ClosureHypReform.lean","6","def","R1Rank1ClosureHypReformAt","def R1Rank1ClosureHypReformAt (_z : Complex) : Prop :="
"R1Rank1ClosureHypReform.lean","13","theorem","R1_rank1_closure_hyp_reform","theorem R1_rank1_closure_hyp_reform"
"R1Rank1ExactClosureReduction.lean","5","def","R1TailWindowSubseqBoundAt","def R1TailWindowSubseqBoundAt (_z : Complex) : Prop := Exists fun C : Real => 0 <= C"
"R1Rank1ExactClosureReduction.lean","11","theorem","R1_rank1_exact_closure_reduction","theorem R1_rank1_exact_closure_reduction"
"R1Rank1MixedFactor.lean","5","def","R1Rank1MixedFactorAt","def R1Rank1MixedFactorAt (p _q : Nat) (_z : Complex) : Prop := Exists fun r : Nat => r = p"
"R1Rank1MixedFactor.lean","6","def","R1SymplecticOrthogonalityAt","def R1SymplecticOrthogonalityAt (p q : Nat) (_z : Complex) : Prop := Exists fun r : Nat => r = p \/ r = q"
"R1Rank1MixedFactor.lean","11","theorem","R1_rank1_mixed_factor","theorem R1_rank1_mixed_factor"
"R1Rank1RadiusfloorDichotomy.lean","5","def","R1BoundedBranchAt","def R1BoundedBranchAt (_z : Complex) : Prop := Exists fun j0 : Nat => 0 <= j0"
"R1Rank1RadiusfloorDichotomy.lean","6","def","R1DivergentBranchAt","def R1DivergentBranchAt (_z : Complex) : Prop := Exists fun j0 : Nat => 0 < j0"
"R1Rank1RadiusfloorDichotomy.lean","11","theorem","R1_rank1_radiusfloor_dichotomy","theorem R1_rank1_radiusfloor_dichotomy"
"R1Rank1StepLinear.lean","6","def","R1Rank1StepLinearAt","def R1Rank1StepLinearAt (_k : Nat) (z : Complex) : Prop :="
"R1Rank1StepLinear.lean","8","def","R1Rank1StepInverseLinearAt","def R1Rank1StepInverseLinearAt (k : Nat) (_z : Complex) : Prop := Exists fun n : Nat => n = k"
"R1Rank1StepLinear.lean","13","theorem","R1_rank1_step_linear","theorem R1_rank1_step_linear"
"R1Rank1TailwindowPrinciple.lean","6","def","R1SubseqPrefixWindowPrincipleAt","def R1SubseqPrefixWindowPrincipleAt (_z : Complex) : Prop := Exists fun j0 : Nat => 0 <= j0 /\ 0 < j0"
"R1Rank1TailwindowPrinciple.lean","7","def","R1RadiusCollapseFromPrefixPrincipleAt","def R1RadiusCollapseFromPrefixPrincipleAt (_z : Complex) : Prop := Exists fun j0 : Nat => 0 <= j0 /\ 0 < j0"
"R1Rank1TailwindowPrinciple.lean","13","theorem","R1_rank1_tailwindow_principle","theorem R1_rank1_tailwindow_principle"
"R1Rank1TransportInvariance.lean","5","def","R1RankOneBlockAt","def R1RankOneBlockAt (_k : Nat) (_z : Complex) : Prop :="
"R1Rank1TransportInvariance.lean","7","def","R1HJHZeroAt","def R1HJHZeroAt (k : Nat) (_z : Complex) : Prop := Exists fun n : Nat => n = k"
"R1Rank1TransportInvariance.lean","8","def","R1TransportInvariantAt","def R1TransportInvariantAt (k : Nat) (_z : Complex) : Prop := Exists fun n : Nat => n = k"
"R1Rank1TransportInvariance.lean","13","theorem","R1_rank1_transport_invariance","theorem R1_rank1_transport_invariance"
"R1SymplOrthCollinearEquiv.lean","5","def","R1PairwiseSymplOrthogonalityAt","def R1PairwiseSymplOrthogonalityAt (_z : Complex) : Prop :="
"R1SymplOrthCollinearEquiv.lean","7","def","R1OneDirectionWindowFamilyAt","def R1OneDirectionWindowFamilyAt (_z : Complex) : Prop :="
"R1SymplOrthCollinearEquiv.lean","13","theorem","R1_sympl_orth_collinear_equiv","theorem R1_sympl_orth_collinear_equiv"
"R1TailwindowDirectFiniteMass.lean","5","def","R1PrefixWindowDirectBoundAt","def R1PrefixWindowDirectBoundAt (_z : Complex) : Prop := Exists fun j0 : Nat => 0 <= j0"
"R1TailwindowDirectFiniteMass.lean","6","def","R1FiniteTotalMassFromPrefixWindowAt","def R1FiniteTotalMassFromPrefixWindowAt (_z : Complex) : Prop := Exists fun j0 : Nat => 0 <= j0 /\ 0 < j0"
"R1TailwindowDirectFiniteMass.lean","11","theorem","R1_tailwindow_direct_finite_mass","theorem R1_tailwindow_direct_finite_mass"
"R1TailwindowPrefixEquiv.lean","5","def","R1TailWindowBoundOnSubseqAt","def R1TailWindowBoundOnSubseqAt (_z : Complex) : Prop := Exists fun j0 : Nat => 0 <= j0 /\ 0 < j0"
"R1TailwindowPrefixEquiv.lean","10","theorem","R1_tailwindow_prefix_equiv","theorem R1_tailwindow_prefix_equiv"
"R1TwoChannelTraceCompare.lean","5","def","R1TwoChannelFrameAt","def R1TwoChannelFrameAt (k j : Nat) (_z : Complex) : Prop := Exists fun n : Nat => n = k \/ n = j"
"R1TwoChannelTraceCompare.lean","6","def","R1TwoChannelTraceCompareAt","def R1TwoChannelTraceCompareAt (k j : Nat) (_z : Complex) : Prop := Exists fun n : Nat => n = k \/ n = j"
"R1TwoChannelTraceCompare.lean","11","theorem","R1_two_channel_trace_compare","theorem R1_two_channel_trace_compare"
"R1UniformEllipticityCollapse.lean","5","def","R1RadiusCollapseFromUniformEllipticityAt","def R1RadiusCollapseFromUniformEllipticityAt (_z : Complex) : Prop :="
"R1UniformEllipticityCollapse.lean","12","theorem","R1_uniform_ellipticity_collapse","theorem R1_uniform_ellipticity_collapse"
"R1UniformEllipticityFiniteMass.lean","6","def","R1UniformEllipticityAt","def R1UniformEllipticityAt (_z : Complex) : Prop :="
"R1UniformEllipticityFiniteMass.lean","8","def","R1FiniteTotalMassFromUniformEllipticityAt","def R1FiniteTotalMassFromUniformEllipticityAt (_z : Complex) : Prop :="
"R1UniformEllipticityFiniteMass.lean","15","theorem","R1_uniform_ellipticity_finite_mass","theorem R1_uniform_ellipticity_finite_mass"
"R2DynamicEquilibrium.lean","5","def","R2SchurCocycleFamilyAt","def R2SchurCocycleFamilyAt (z : Complex) : Prop := Exists fun w : Complex => w = z"
"R2DynamicEquilibrium.lean","6","def","R2GyroGyrationLawAt","def R2GyroGyrationLawAt (_z : Complex) : Prop :="
"R2DynamicEquilibrium.lean","8","def","R2GyroAngleSeriesLawAt","def R2GyroAngleSeriesLawAt (_z : Complex) : Prop := Exists fun s0 : Nat => 0 < s0"
"R2DynamicEquilibrium.lean","9","def","R2DynamicEquilibriumNormalFormAt","def R2DynamicEquilibriumNormalFormAt (_z : Complex) : Prop :="
"R2DynamicEquilibrium.lean","11","def","R2LeakageAdditivityAt","def R2LeakageAdditivityAt (_z : Complex) : Prop :="
"R2DynamicEquilibrium.lean","18","theorem","R2_dynamic_equilibrium","theorem R2_dynamic_equilibrium"
"ReverseRH.lean","17","theorem","reverse_RH_core","theorem reverse_RH_core"
"ReverseRH.lean","24","theorem","reverse_RH_core_via_nevanlinna","theorem reverse_RH_core_via_nevanlinna"
"ReverseRH.lean","34","theorem","reverse_RH_via_conj_zero","theorem reverse_RH_via_conj_zero"
"ReverseRH.lean","41","theorem","reverse_RH","theorem reverse_RH"
"ReverseRH.lean","49","theorem","reverse_RH_via_nevanlinna","theorem reverse_RH_via_nevanlinna"
"ReverseRH.lean","60","theorem","reverse_RH_via_conjugation_symmetry","theorem reverse_RH_via_conjugation_symmetry"
"ReverseRH.lean","69","theorem","reverse_RH_via_nevanlinna_conjugation_symmetry","theorem reverse_RH_via_nevanlinna_conjugation_symmetry"
"ReverseRH.lean","78","theorem","reverse_RH_via_xi_functional_symmetry","theorem reverse_RH_via_xi_functional_symmetry"
"ReverseRH.lean","87","theorem","reverse_RH_via_nevanlinna_xi_functional_symmetry","theorem reverse_RH_via_nevanlinna_xi_functional_symmetry"
"ReverseRH.lean","96","theorem","reverse_RH_via_cayley","theorem reverse_RH_via_cayley"
"ReverseRH.lean","108","theorem","reverse_RH_via_cayley_conjugation_symmetry","theorem reverse_RH_via_cayley_conjugation_symmetry"
"ReverseRH.lean","119","theorem","reverse_RH_via_cayley_xi_functional_symmetry","theorem reverse_RH_via_cayley_xi_functional_symmetry"
"RHFromAnchor.lean","5","def","HasOnlyRealZeros","def HasOnlyRealZeros (f : Complex -> Complex) : Prop :="
"RHFromAnchor.lean","8","def","HolomorphicOnUpperHalfPlane","def HolomorphicOnUpperHalfPlane (F : Complex -> Complex) : Prop :="
"RHFromAnchor.lean","11","def","HerglotzOnUpperHalfPlane","def HerglotzOnUpperHalfPlane (H : Complex -> Complex) : Prop :="
"RHFromAnchor.lean","15","def","SchurOnUpperHalfPlane","def SchurOnUpperHalfPlane (W : Complex -> Complex) : Prop :="
"RHFromAnchor.lean","19","def","HasCanonicalSystemEnergyRealization","def HasCanonicalSystemEnergyRealization (_H : Complex -> Complex) : Prop :="
"RHFromAnchor.lean","26","theorem","rh_from_anchor","theorem rh_from_anchor"
"RHFromLstar.lean","5","def","RiemannHypothesis","def RiemannHypothesis (f : Complex -> Complex) : Prop := HasOnlyRealZeros f"
"RHFromLstar.lean","7","def","ConjugationSymmetric","def ConjugationSymmetric (f : Complex -> Complex) : Prop :="
"RHFromLstar.lean","10","def","XiFunctionalSymmetry","def XiFunctionalSymmetry (f : Complex -> Complex) : Prop :="
"RHFromLstar.lean","14","theorem","conjugation_symmetric_of_xi_functional_symmetry","theorem conjugation_symmetric_of_xi_functional_symmetry"
"RHFromLstar.lean","20","theorem","conj_zero_of_conjugation_symmetric","theorem conj_zero_of_conjugation_symmetric"
"RHFromLstar.lean","37","theorem","rh_from_lstar_core","theorem rh_from_lstar_core"
"RHFromLstar.lean","56","theorem","zero_free_of_nevanlinna","theorem zero_free_of_nevanlinna"
"RHFromLstar.lean","63","theorem","rh_from_lstar_core_via_nevanlinna","theorem rh_from_lstar_core_via_nevanlinna"
"RHFromLstar.lean","73","theorem","rh_from_lstar","theorem rh_from_lstar"
"RHFromLstar.lean","81","theorem","rh_from_lstar_via_conjugation_symmetry","theorem rh_from_lstar_via_conjugation_symmetry"
"RHFromLstar.lean","91","theorem","rh_from_lstar_via_xi_functional_symmetry","theorem rh_from_lstar_via_xi_functional_symmetry"
"RHFromLstar.lean","101","theorem","zero_free_and_conjugation_symmetry_suffice","theorem zero_free_and_conjugation_symmetry_suffice"
"RHFromLstar.lean","110","theorem","zero_free_on_upper_not_sufficient","theorem zero_free_on_upper_not_sufficient :"
"RHFromLstar.lean","128","theorem","conjugation_symmetric_not_sufficient","theorem conjugation_symmetric_not_sufficient :"
"RTo1SchurLimit.lean","5","def","R2SchurFamilyUniformBoundAt","def R2SchurFamilyUniformBoundAt (_z : Complex) : Prop :="
"RTo1SchurLimit.lean","7","def","R2PointwiseRToOneLimitAt","def R2PointwiseRToOneLimitAt (_z : Complex) : Prop :="
"RTo1SchurLimit.lean","9","def","R2LocallyUniformSchurLimitAt","def R2LocallyUniformSchurLimitAt (_z : Complex) : Prop :="
"RTo1SchurLimit.lean","11","def","R2SchurLimitBoundaryValuesAt","def R2SchurLimitBoundaryValuesAt (_z : Complex) : Prop :="
"RTo1SchurLimit.lean","18","theorem","r_to_1_schur_limit","theorem r_to_1_schur_limit"
"SchurDeBranges.lean","5","def","DeBrangesKernelPSD","def DeBrangesKernelPSD (_E : Complex -> Complex) : Prop :="
"SchurDeBranges.lean","8","def","WeakHermiteBiehler","def WeakHermiteBiehler (_E : Complex -> Complex) : Prop :="
"SchurDeBranges.lean","11","def","ZeroFreeOnUpper","def ZeroFreeOnUpper (E : Complex -> Complex) : Prop :="
"SchurDeBranges.lean","21","theorem","schur_debranges","theorem schur_debranges"
"SchurLocalUpdates.lean","8","theorem","schur_step_formula_nonzero","theorem schur_step_formula_nonzero"
"SchurLocalUpdates.lean","23","theorem","alpha_k1_exact","theorem alpha_k1_exact"
"SchurLocalUpdates.lean","40","theorem","bk1_exact_coeff","theorem bk1_exact_coeff"
"SelfadjointCompact.lean","5","def","SelfadjointCompactAt","def SelfadjointCompactAt (_z : Complex) : Prop :="
"SelfadjointCompact.lean","11","theorem","selfadjoint_compact","theorem selfadjoint_compact"
"StieltjesDiffquot.lean","5","def","StieltjesDiffquotAt","def StieltjesDiffquotAt (z : Complex) : Prop :="
"StieltjesDiffquot.lean","12","theorem","stieltjes_diffquot","theorem stieltjes_diffquot"
"TraceLowerBound.lean","5","def","R1SchurHamiltonianBlockFamilyAt","def R1SchurHamiltonianBlockFamilyAt (_z : Complex) : Prop :="
"TraceLowerBound.lean","7","def","R1TraceLowerBoundAt","def R1TraceLowerBoundAt (_z : Complex) : Prop :="
"TraceLowerBound.lean","9","def","R1MassDivergesFromTraceLowerBoundAt","def R1MassDivergesFromTraceLowerBoundAt (_z : Complex) : Prop :="
"TraceLowerBound.lean","15","theorem","trace_lower_bound","theorem trace_lower_bound"
"VerticalConvolution.lean","5","def","XiAlphaVerticalConvolutionIdentityAt","def XiAlphaVerticalConvolutionIdentityAt (_z : Complex) : Prop :="
"VerticalConvolution.lean","7","def","XiAlphaKernelBoundAt","def XiAlphaKernelBoundAt (_z : Complex) : Prop :="
"VerticalConvolution.lean","13","theorem","vertical_convolution","theorem vertical_convolution"
"W0.lean","8","theorem","W0","theorem W0"
"WBoundedCharacteristic.lean","5","def","WBoundedCharacteristicOnStrips","def WBoundedCharacteristicOnStrips (W : Complex -> Complex) : Prop :="
"WBoundedCharacteristic.lean","11","theorem","W_bounded_characteristic","theorem W_bounded_characteristic"
"WeylCalibration.lean","7","def","IsHerglotzOn","def IsHerglotzOn (s : Set Complex) (m : Complex -> Complex) : Prop :="
"WeylCalibration.lean","12","def","IsHermiteBiehler","def IsHermiteBiehler (E : Complex -> Complex) : Prop :="
"WeylCalibration.lean","17","def","RealInterlacingData","def RealInterlacingData (A B : Complex -> Complex) : Prop :="
"WeylCalibration.lean","20","theorem","herglotz_transfer_of_eqOn","theorem herglotz_transfer_of_eqOn"
"WeylCalibration.lean","32","theorem","weyl_calibration_core","theorem weyl_calibration_core"
"WeylCalibration.lean","49","theorem","weyl_calibration_with_hb","theorem weyl_calibration_with_hb"
"WeylDerivativeResolventSquare.lean","5","def","WeylDerivativeResolventSquareAt","def WeylDerivativeResolventSquareAt (z : Complex) : Prop :="
"WeylDerivativeResolventSquare.lean","11","theorem","weyl_derivative_resolvent_square","theorem weyl_derivative_resolvent_square"
"WeylIsHerglotz.lean","5","def","WeylIsHerglotzAt","def WeylIsHerglotzAt (z : Complex) : Prop :="
"WeylIsHerglotz.lean","11","theorem","weyl_is_herglotz","theorem weyl_is_herglotz"
"WGlobalSchur.lean","5","def","WGlobalSchurOnUpperHalfPlane","def WGlobalSchurOnUpperHalfPlane (W : Complex -> Complex) : Prop :="
"WGlobalSchur.lean","11","theorem","W_global_schur","theorem W_global_schur"
"WInftyLimit.lean","5","def","R2WInftyLimitAt","def R2WInftyLimitAt (_z : Complex) : Prop := Exists fun N : Nat => 0 < N"
"WInftyLimit.lean","10","theorem","W_infty_limit","theorem W_infty_limit"
"WStripSchur.lean","5","def","WStripSchurOnUpperStrip","def WStripSchurOnUpperStrip (W : Complex -> Complex) : Prop :="
"WStripSchur.lean","12","theorem","W_strip_schur","theorem W_strip_schur"
"WUnitReal.lean","5","def","WUnitModulusOnReal","def WUnitModulusOnReal (W : Complex -> Complex) : Prop :="
"WUnitReal.lean","11","theorem","W_unit_real","theorem W_unit_real"
"XiAlphaToXi.lean","5","def","XiAlphaToXiTransferAt","def XiAlphaToXiTransferAt (_z : Complex) : Prop :="
"XiAlphaToXi.lean","11","theorem","Xi_alpha_to_Xi","theorem Xi_alpha_to_Xi"
