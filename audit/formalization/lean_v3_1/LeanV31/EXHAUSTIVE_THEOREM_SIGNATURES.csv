"file","line","kind","name","signature"
"BcPoissonStrip.lean","12","theorem","bc_poisson_strip","theorem bc_poisson_strip {F : Complex -> Complex} (hSmirnovBridge : StripBoundaryMaximumPrinciple F) : StripBoundaryMaximumPrinciple F := by"
"BDetector.lean","11","theorem","b_detector","theorem b_detector {H : Complex -> Complex} (hLocator : HardyPoleLocatorOnCircle H) : BDetectorFunctionalOnCircle H := by"
"BDetectorGram.lean","11","theorem","b_detector_gram","theorem b_detector_gram {H : Complex -> Complex} (hGramBridge : BDetectorGramIdentity H) : BDetectorGramIdentity H := by"
"CalibArithStieltjes.lean","11","theorem","calib_arith_stieltjes","theorem calib_arith_stieltjes {z : Complex} (hBridge : ArithStieltjesModelAt z) : ArithStieltjesModelAt z := by"
"CalibKernelMatch.lean","11","theorem","calib_kernel_match","theorem calib_kernel_match {z : Complex} (hLocalGreen : LocalGreenBridgeIdentityAt z) (hBridge : LocalGreenBridgeIdentityAt z -> CalibKernelMatchAt z) : CalibKernelMatchAt z := by"
"CanonicalTruncDetector0B21.lean","12","theorem","canonical_trunc_detector0","theorem canonical_trunc_detector0 (hModeBridge : TruncationWeylHerglotzFamily (fun _ _ => 0) -> forall (n : Nat), NoNegativeModesOnCircle n) (hDefectBridge : (forall (n : Nat), NoNegativeModesOnCircle n) -> forall (n : Nat), DetectorDefectZeroAtLevel n) (hFamily : TruncationWeylHerglotzFamily (fun _ _ => 0)) : (forall (n : Nat), NoNegativeModesOnCircle n) /\ (forall (n : Nat), DetectorDefectZeroAtLevel n) := by"
"CayleyEquiv.lean","11","theorem","cayley_equiv","theorem cayley_equiv {H W : Complex -> Complex} (hW : W = cayleyOf H) (hPointwise : forall z, z ??cUpper -> (0 <= Complex.im (H z) <-> ?뻎 z??<= 1)) (hPointwiseStrict : forall z, z ??cUpper -> (0 < Complex.im (H z) <-> ?뻎 z??< 1)) : ((forall z, z ??cUpper -> 0 <= Complex.im (H z)) <-> (forall z, z ??cUpper -> ?뻎 z??<= 1)) /\ ((forall z, z ??cUpper -> 0 < Complex.im (H z)) <-> (forall z, z ??cUpper -> ?뻎 z??< 1)) := by"
"CholCert.lean","11","theorem","chol_cert","theorem chol_cert {z : Complex} (hResidualData : A2ApproxCholeskyResidualAt z) (hCertBridge : A2ApproxCholeskyResidualAt z -> A2CholCertAt z) : A2CholCertAt z := by"
"CircleHardyCertificate.lean","12","theorem","circle_hardy_certificate","theorem circle_hardy_certificate {f H : Complex -> Complex} (hDetector : BDetectorFunctionalOnCircle H) (hCertificateBridge : BDetectorFunctionalOnCircle H -> CircleHardyZeroFreeCertificate f H) : CircleHardyZeroFreeCertificate f H := by"
"DiscreteLagrangeGramB21.lean","12","theorem","discrete_lagrange_gram","theorem discrete_lagrange_gram (hTelescope : forall (n : Nat) (z w : Complex), InUpperB21 z -> InUpperB21 w -> GramSumIdentityAt n z w) (hPsdFromGram : (forall (n : Nat) (z w : Complex), InUpperB21 z -> InUpperB21 w -> GramSumIdentityAt n z w) -> forall (n : Nat), MatrixPickKernelPSDAtLevel n) : (forall (n : Nat) (z w : Complex), InUpperB21 z -> InUpperB21 w -> GramSumIdentityAt n z w) /\ (forall (n : Nat), MatrixPickKernelPSDAtLevel n) := by"
"EnergyIdentityB21.lean","16","theorem","energy_identity","theorem energy_identity {zeta : Complex} {M R H : Complex -> Complex} (hIm : UpperHalfPlanePoint zeta) (hRinv : RInvertibleAt zeta R) (hFormula : EnergyIdentityAt zeta M R H) (hPSD : PositiveSemidefiniteTransport zeta R H) (hContractiveBridge : UpperHalfPlanePoint zeta -> RInvertibleAt zeta R -> EnergyIdentityAt zeta M R H -> PositiveSemidefiniteTransport zeta R H -> JContractiveAt zeta M) : EnergyIdentityAt zeta M R H /\ PositiveSemidefiniteTransport zeta R H /\ JContractiveAt zeta M := by"
"FinalBridgeClosed.lean","17","theorem","final_bridge_closed_core","theorem final_bridge_closed_core {f : Complex -> Complex} (hZeroFree : ZeroFreeOnUpper f) (hConjSymm : ConjugationSymmetric f) : RiemannHypothesis f := by"
"FinalBridgeClosed.lean","26","theorem","final_bridge_closed_core_via_nevanlinna","theorem final_bridge_closed_core_via_nevanlinna {f H : Complex -> Complex} (hHerglotz : HerglotzOnUpperHalfPlane H) (hNevanlinnaExclusion : StripPoleExclusionViaNevanlinna f H) (hConjSymm : ConjugationSymmetric f) : RiemannHypothesis f := by"
"FinalBridgeClosed.lean","35","theorem","final_bridge_closed_via_conj_zero","theorem final_bridge_closed_via_conj_zero {f : Complex -> Complex} (hZeroFree : ZeroFreeOnUpper f) (hConjZero : forall z : Complex, f z = 0 -> f (star z) = 0) : RiemannHypothesis f := by"
"FinalBridgeClosed.lean","42","theorem","final_bridge_closed","theorem final_bridge_closed {f : Complex -> Complex} -- Core closure endpoint used for root-assumption reduction batches. (hZeroFree : ZeroFreeOnUpper f) (hConjSymm : ConjugationSymmetric f) : RiemannHypothesis f := by"
"FinalBridgeClosed.lean","50","theorem","final_bridge_closed_via_nevanlinna","theorem final_bridge_closed_via_nevanlinna {f H : Complex -> Complex} -- This route is the explicit `lem:no_pole_nevanlinna` -> `lem:no_zeros_from_herglotz` bridge path. (hHerglotz : HerglotzOnUpperHalfPlane H) (hNevanlinnaExclusion : StripPoleExclusionViaNevanlinna f H) (hConjSymm : ConjugationSymmetric f) : RiemannHypothesis f := by"
"FinalBridgeClosed.lean","59","theorem","final_bridge_closed_via_detector_conjugation_symmetry","theorem final_bridge_closed_via_detector_conjugation_symmetry {f H : Complex -> Complex} (hDetector : BDetectorFunctionalOnCircle H) (hCertificateBridge : BDetectorFunctionalOnCircle H -> CircleHardyZeroFreeCertificate f H) (hConjSymm : ConjugationSymmetric f) : RiemannHypothesis f := by"
"FinalBridgeClosed.lean","70","theorem","final_bridge_closed_via_detector_xi_functional_symmetry","theorem final_bridge_closed_via_detector_xi_functional_symmetry {f H : Complex -> Complex} (hDetector : BDetectorFunctionalOnCircle H) (hCertificateBridge : BDetectorFunctionalOnCircle H -> CircleHardyZeroFreeCertificate f H) (hXiSymm : XiFunctionalSymmetry f) : RiemannHypothesis f := by"
"FinalBridgeClosed.lean","83","theorem","final_bridge_closed_via_hardy_locator_conjugation_symmetry","theorem final_bridge_closed_via_hardy_locator_conjugation_symmetry {f H : Complex -> Complex} -- Paper chain S007 -> S008 -> S009, then RH closure via symmetry. (hGram : BDetectorGramIdentity H) (hLocatorBridge : BDetectorGramIdentity H -> HardyPoleLocatorOnCircle H) (hCertificateBridge : BDetectorFunctionalOnCircle H -> CircleHardyZeroFreeCertificate f H) (hConjSymm : ConjugationSymmetric f) : RiemannHypothesis f := by"
"FinalBridgeClosed.lean","100","theorem","final_bridge_closed_via_hardy_locator_xi_functional_symmetry","theorem final_bridge_closed_via_hardy_locator_xi_functional_symmetry {f H : Complex -> Complex} -- Paper chain S007 -> S008 -> S009, then RH closure via xi symmetry. (hGram : BDetectorGramIdentity H) (hLocatorBridge : BDetectorGramIdentity H -> HardyPoleLocatorOnCircle H) (hCertificateBridge : BDetectorFunctionalOnCircle H -> CircleHardyZeroFreeCertificate f H) (hXiSymm : XiFunctionalSymmetry f) : RiemannHypothesis f := by"
"FinalBridgeClosed.lean","117","theorem","final_bridge_closed_via_canonical_trunc_conjugation_symmetry","theorem final_bridge_closed_via_canonical_trunc_conjugation_symmetry {f H : Complex -> Complex} -- Extended paper chain: -- S028 (canonical trunc detector-zero) -> S007 -> S008 -> S009 -> RH closure. (hModeBridge : TruncationWeylHerglotzFamily (fun _ _ => 0) -> forall (n : Nat), NoNegativeModesOnCircle n) (hDefectBridge : (forall (n : Nat), NoNegativeModesOnCircle n) -> forall (n : Nat), DetectorDefectZeroAtLevel n) (hFamily : TruncationWeylHerglotzFamily (fun _ _ => 0)) (hDefectToGram : (forall (n : Nat), DetectorDefectZeroAtLevel n) -> BDetectorGramIdentity H) (hLocatorBridge : BDetectorGramIdentity H -> HardyPoleLocatorOnCircle H) (hCertificateBridge : BDetectorFunctionalOnCircle H -> CircleHardyZeroFreeCertificate f H) (hConjSymm : ConjugationSymmetric f) : RiemannHypothesis f := by"
"FinalBridgeClosed.lean","146","theorem","final_bridge_closed_via_canonical_trunc_xi_functional_symmetry","theorem final_bridge_closed_via_canonical_trunc_xi_functional_symmetry {f H : Complex -> Complex} -- Extended paper chain: -- S028 (canonical trunc detector-zero) -> S007 -> S008 -> S009 -> RH closure. (hModeBridge : TruncationWeylHerglotzFamily (fun _ _ => 0) -> forall (n : Nat), NoNegativeModesOnCircle n) (hDefectBridge : (forall (n : Nat), NoNegativeModesOnCircle n) -> forall (n : Nat), DetectorDefectZeroAtLevel n) (hFamily : TruncationWeylHerglotzFamily (fun _ _ => 0)) (hDefectToGram : (forall (n : Nat), DetectorDefectZeroAtLevel n) -> BDetectorGramIdentity H) (hLocatorBridge : BDetectorGramIdentity H -> HardyPoleLocatorOnCircle H) (hCertificateBridge : BDetectorFunctionalOnCircle H -> CircleHardyZeroFreeCertificate f H) (hXiSymm : XiFunctionalSymmetry f) : RiemannHypothesis f := by"
"FinalBridgeClosed.lean","175","theorem","final_bridge_closed_via_conjugation_symmetry","theorem final_bridge_closed_via_conjugation_symmetry {f : Complex -> Complex} (hZeroFree : ZeroFreeOnUpper f) (hConjSymm : ConjugationSymmetric f) : RiemannHypothesis f := by"
"FinalBridgeClosed.lean","182","theorem","final_bridge_closed_via_nevanlinna_conjugation_symmetry","theorem final_bridge_closed_via_nevanlinna_conjugation_symmetry {f H : Complex -> Complex} (hHerglotz : HerglotzOnUpperHalfPlane H) (hNevanlinnaExclusion : StripPoleExclusionViaNevanlinna f H) (hConjSymm : ConjugationSymmetric f) : RiemannHypothesis f := by"
"FinalBridgeClosed.lean","190","theorem","final_bridge_closed_via_xi_functional_symmetry","theorem final_bridge_closed_via_xi_functional_symmetry {f : Complex -> Complex} (hZeroFree : ZeroFreeOnUpper f) (hXiSymm : XiFunctionalSymmetry f) : RiemannHypothesis f := by"
"FinalBridgeClosed.lean","199","theorem","final_bridge_closed_via_nevanlinna_xi_functional_symmetry","theorem final_bridge_closed_via_nevanlinna_xi_functional_symmetry {f H : Complex -> Complex} (hHerglotz : HerglotzOnUpperHalfPlane H) (hNevanlinnaExclusion : StripPoleExclusionViaNevanlinna f H) (hXiSymm : XiFunctionalSymmetry f) : RiemannHypothesis f := by"
"FinalBridgeClosed.lean","209","theorem","final_bridge_closed_via_cayley","theorem final_bridge_closed_via_cayley {f H W : Complex -> Complex} -- Paper-facing transport route: `prop:W_global_schur` + `lem:cayley_equiv`. (hGlobalSchur : WGlobalSchurOnUpperHalfPlane W) (hCayleyEquiv : HerglotzOnUpperHalfPlane H <-> SchurOnUpperHalfPlane W) (hNevanlinnaExclusion : StripPoleExclusionViaNevanlinna f H) (hConjZero : forall z : Complex, f z = 0 -> f (star z) = 0) : RiemannHypothesis f := by"
"FinalBridgeClosed.lean","219","theorem","final_bridge_closed_via_cayley_conjugation_symmetry","theorem final_bridge_closed_via_cayley_conjugation_symmetry {f H W : Complex -> Complex} (hGlobalSchur : WGlobalSchurOnUpperHalfPlane W) (hCayleyEquiv : HerglotzOnUpperHalfPlane H <-> SchurOnUpperHalfPlane W) (hNevanlinnaExclusion : StripPoleExclusionViaNevanlinna f H) (hConjSymm : ConjugationSymmetric f) : RiemannHypothesis f := by"
"FinalBridgeClosed.lean","229","theorem","final_bridge_closed_via_cayley_xi_functional_symmetry","theorem final_bridge_closed_via_cayley_xi_functional_symmetry {f H W : Complex -> Complex} (hGlobalSchur : WGlobalSchurOnUpperHalfPlane W) (hCayleyEquiv : HerglotzOnUpperHalfPlane H <-> SchurOnUpperHalfPlane W) (hNevanlinnaExclusion : StripPoleExclusionViaNevanlinna f H) (hXiSymm : XiFunctionalSymmetry f) : RiemannHypothesis f := by"
"FinalBridgeClosed.lean","239","theorem","nevanlinna_route_not_sufficient_without_symmetry","theorem nevanlinna_route_not_sufficient_without_symmetry : Exists fun f : Complex -> Complex => Exists fun H : Complex -> Complex => HerglotzOnUpperHalfPlane H /\ StripPoleExclusionViaNevanlinna f H /\ Not (RiemannHypothesis f) := by"
"GaussianNormalizationNonzero.lean","11","theorem","gaussian_normalization_nonzero","theorem gaussian_normalization_nonzero {z : Complex} (hKernelBound : XiAlphaKernelBoundAt z) (hNormalizationBridge : XiAlphaKernelBoundAt z -> XiAlphaGaussianNormalizationNonzeroAt z) : XiAlphaGaussianNormalizationNonzeroAt z := by"
"GyroAngleSeries.lean","11","theorem","gyro_angle_series","theorem gyro_angle_series {z : Complex} (hGyrationPhase : R2GyrationPhaseLawAt z) (hSeriesBridge : R2GyrationPhaseLawAt z -> R2GyroAngleSeriesLawAt z) (hTailBridge : R2GyroAngleSeriesLawAt z -> R2GyroAngleTailBoundAt z) : R2GyroAngleSeriesLawAt z /\ R2GyroAngleTailBoundAt z := by"
"GyroGyration.lean","16","theorem","gyro_gyration","theorem gyro_gyration {z : Complex} (hGyroLaw : R2GyroassociativityLawAt z) (hPhaseBridge : R2GyroassociativityLawAt z -> R2GyrationPhaseLawAt z) (hFactorBridge : R2GyrationPhaseLawAt z -> R2TauFactorizationLawAt z) : R2GyroassociativityLawAt z /\ R2GyrationPhaseLawAt z /\ R2TauFactorizationLawAt z := by"
"GyroTailConvergence.lean","11","theorem","gyro_tail_convergence","theorem gyro_tail_convergence {z : Complex} (hAngleSeries : R2GyroAngleSeriesLawAt z) (hAngleTail : R2GyroAngleTailBoundAt z) (hTailBridge : R2GyroAngleSeriesLawAt z -> R2GyroAngleTailBoundAt z -> R2GyroTailConvergenceAt z) : R2GyroTailConvergenceAt z := by"
"HardyPoleLocator.lean","11","theorem","hardy_pole_locator","theorem hardy_pole_locator {H : Complex -> Complex} (hGram : BDetectorGramIdentity H) (hLocatorBridge : BDetectorGramIdentity H -> HardyPoleLocatorOnCircle H) : HardyPoleLocatorOnCircle H := by"
"HighlineContraction.lean","14","theorem","highline_contraction","theorem highline_contraction {W : Complex -> Complex} (hContractionBridge : HighlineStrictContraction W) : HighlineStrictContraction W := by"
"HInftyPinning.lean","12","theorem","H_infty_pinning","theorem H_infty_pinning {z : Complex} (hStirlingBridge : R2HInftyAsymptoticPinningAt z) : R2HInftyAsymptoticPinningAt z := by"
"HurwitzTransfer.lean","18","theorem","hurwitz_rect_transfer","theorem hurwitz_rect_transfer {Xi : Complex -> Complex} {XiFamily : Real -> Complex -> Complex} {R boundary : Set Complex} (hUniformBoundary : Exists fun alphaR : Real => 0 < alphaR /\ forall alpha : Real, 0 < alpha -> alpha < alphaR -> forall z, boundary z -> ?뻏iFamily alpha z - Xi z??< ?뻏i z?? (hRoucheBridge : forall alpha : Real, NoZerosOn (XiFamily alpha) boundary -> SameZeroCountIn (XiFamily alpha) Xi R) : Exists fun alphaR : Real => 0 < alphaR /\ forall alpha : Real, 0 < alpha -> alpha < alphaR -> NoZerosOn (XiFamily alpha) boundary /\ SameZeroCountIn (XiFamily alpha) Xi R := by"
"IDAssumptionsVerifiedR1.lean","15","theorem","ID_assumptions_verified","theorem ID_assumptions_verified (hI1Bridge : TraceLowerBoundAvailable -> R1LimitPointAvailable -> LimitPointUniqueLimitAvailable -> IdentificationInputI1) (hI2Bridge : JetConsistencyAvailable -> IdentificationInputI2) (hI3Bridge : CanonicalTruncDetector0Available -> IdentificationInputI3) (hTrace : TraceLowerBoundAvailable) (hR1 : R1LimitPointAvailable) (hLimit : LimitPointUniqueLimitAvailable) (hJet : JetConsistencyAvailable) (hDetector : CanonicalTruncDetector0Available) : IdentificationInputI1 /\ IdentificationInputI2 /\ IdentificationInputI3 := by"
"IDUnconditionalR1.lean","18","theorem","ID_unconditional","theorem ID_unconditional {Stgt Scal : Complex -> Complex} (hI1 : IdentificationInputI1) (hI2 : IdentificationInputI2) (hI3 : IdentificationInputI3) (hGermBridge : IdentificationInputI1 -> IdentificationInputI2 -> EqualOnUnitDisk Stgt Scal) (hRigidityBridge : IdentificationInputI3 -> EqualOnUnitDisk Stgt Scal -> HolomorphicOnUnitDisk Stgt) : HolomorphicOnUnitDisk Stgt /\ EqualOnUnitDisk Stgt Scal := by"
"IndependentInequality.lean","15","theorem","independent_inequality","theorem independent_inequality {z : Complex} (hNonneg : R2IndependentInequalityAt z) (hRigidityBridge : R2IndependentInequalityAt z -> R2IndependentInequalityRigidityAt z) : R2IndependentInequalityAt z /\ R2IndependentInequalityRigidityAt z := by"
"IndependentInequality.lean","31","theorem","independent_inequality_eigen_nonneg","theorem independent_inequality_eigen_nonneg {lam1 lam2 : Real} (h1 : 0 <= lam1) (h2 : 0 <= lam2) : 0 <= (lam1 + lam2) - 2 * Real.sqrt (lam1 * lam2) := by"
"IndependentInequality.lean","51","theorem","independent_inequality_eigen_rigidity","theorem independent_inequality_eigen_rigidity {lam1 lam2 : Real} (h1 : 0 <= lam1) (h2 : 0 <= lam2) : ((lam1 + lam2) - 2 * Real.sqrt (lam1 * lam2) = 0) <-> lam1 = lam2 := by"
"JetConsistencyB21.lean","12","theorem","jet_consistency","theorem jet_consistency {S : Complex -> Complex} (hForward : ForwardSchurRecursionWellDefined S) (hReverse : forall (n : Nat), ReverseSchurTruncationWellDefined S n) (hJetBridge : ForwardSchurRecursionWellDefined S -> (forall (n : Nat), ReverseSchurTruncationWellDefined S n) -> forall (n : Nat), JetMatchAtLevel S n) : (forall (n : Nat), ReverseSchurTruncationWellDefined S n) /\ (forall (n : Nat), JetMatchAtLevel S n) := by"
"LimitPointUniqueLimit.lean","20","theorem","limit_point_unique_limit","theorem limit_point_unique_limit {m : Nat -> Complex -> Complex} (hFam : TruncationWeylHerglotzFamily m) (hRadiusCollapse : RadiusCollapsePointwise m) (hUniqueBridge : TruncationWeylHerglotzFamily m -> RadiusCollapsePointwise m -> UniqueHerglotzLimitFor m) (hLocalUniformBridge : TruncationWeylHerglotzFamily m -> UniqueHerglotzLimitFor m -> LocallyUniformConvergenceFor m) (hBoundaryBridge : RadiusCollapsePointwise m -> UniqueHerglotzLimitFor m -> BoundaryParameterIndependentFor m) : UniqueHerglotzLimitFor m /\ LocallyUniformConvergenceFor m /\ BoundaryParameterIndependentFor m := by"
"LocalDerivativeAnchorTail.lean","9","theorem","constantGap_anchor_eq","theorem constantGap_anchor_eq {D : Type*} {m1 m2 : D -> Real} (hconst : exists c : Real, forall z : D, m1 z - m2 z = c) (z0 : D) (h0 : m1 z0 = m2 z0) : forall z : D, m1 z = m2 z := by"
"LocalDerivativeAnchorTail.lean","24","theorem","deriv_eqOn_of_eqOn_nonempty_open_subset","theorem deriv_eqOn_of_eqOn_nonempty_open_subset {s u : Set Complex} (hs : IsOpen s) (hconn : IsPreconnected s) (hu : IsOpen u) (hu_sub : u ??s) (hu_nonempty : u.Nonempty) {m1 m2 : Complex -> Complex} (hm1 : DifferentiableOn Complex m1 s) (hm2 : DifferentiableOn Complex m2 s) (hderiv_u : u.EqOn (deriv m1) (deriv m2)) : s.EqOn (deriv m1) (deriv m2) := by"
"LocalDerivativeAnchorTail.lean","46","theorem","local_diffquot_constant_gap","theorem local_diffquot_constant_gap {s u : Set Complex} (hs : IsOpen s) (hconn : IsPreconnected s) (hu : IsOpen u) (hu_sub : u ??s) (hu_nonempty : u.Nonempty) {m1 m2 : Complex -> Complex} (hm1 : DifferentiableOn Complex m1 s) (hm2 : DifferentiableOn Complex m2 s) (hderiv_u : u.EqOn (deriv m1) (deriv m2)) : exists c : Complex, s.EqOn (fun z => m1 z - m2 z) (fun _ => c) := by"
"LocalDerivativeAnchorTail.lean","65","theorem","local_derivative_anchor_equal","theorem local_derivative_anchor_equal {s u : Set Complex} (hs : IsOpen s) (hconn : IsPreconnected s) (hu : IsOpen u) (hu_sub : u ??s) (hu_nonempty : u.Nonempty) {m1 m2 : Complex -> Complex} (hm1 : DifferentiableOn Complex m1 s) (hm2 : DifferentiableOn Complex m2 s) (hderiv_u : u.EqOn (deriv m1) (deriv m2)) {z0 : Complex} (hz0u : z0 ??u) (h0 : m1 z0 = m2 z0) : s.EqOn m1 m2 := by"
"LocalDerivativeAnchorTail.lean","89","theorem","pick_kernel_equal","theorem pick_kernel_equal {s u : Set Complex} (hs : IsOpen s) (hconn : IsPreconnected s) (hu : IsOpen u) (hu_sub : u ??s) (hu_nonempty : u.Nonempty) {m1 m2 : Complex -> Complex} (hm1 : DifferentiableOn Complex m1 s) (hm2 : DifferentiableOn Complex m2 s) (hderiv_u : u.EqOn (deriv m1) (deriv m2)) {z0 : Complex} (hz0u : z0 ??u) (h0 : m1 z0 = m2 z0) : s.EqOn m1 m2 ??      (forall z, z ??s -> forall w, w ??s -> z ??w -> (m1 w - m1 z) / (w - z) = (m2 w - m2 z) / (w - z)) := by"
"LocalGreenBridgeIdentity.lean","11","theorem","local_green_bridge_identity","theorem local_green_bridge_identity {z : Complex} (hArithDerivative : ArithChartDerivativeAt z) (hBridge : ArithChartDerivativeAt z -> LocalGreenBridgeIdentityAt z) : LocalGreenBridgeIdentityAt z := by"
"LstarPackage.lean","8","theorem","lstar_equivalence_package","theorem lstar_equivalence_package {H W E : Complex -> Complex} (h1 : HerglotzOnUpperHalfPlane H <-> SchurOnUpperHalfPlane W) (h2 : HerglotzOnUpperHalfPlane H <-> KernelPSDOnUpper (pickKernelH H)) (h3 : SchurOnUpperHalfPlane W <-> KernelPSDOnUpper (pickKernelW W)) (h4 : SchurOnUpperHalfPlane W <-> DeBrangesKernelPSD E) (h5 : SchurOnUpperHalfPlane W <-> WeakHermiteBiehler E) : (HerglotzOnUpperHalfPlane H <-> SchurOnUpperHalfPlane W) /\ (HerglotzOnUpperHalfPlane H <-> KernelPSDOnUpper (pickKernelH H)) /\ (SchurOnUpperHalfPlane W <-> KernelPSDOnUpper (pickKernelW W)) /\ (SchurOnUpperHalfPlane W <-> DeBrangesKernelPSD E) /\ (SchurOnUpperHalfPlane W <-> WeakHermiteBiehler E) := by"
"MainReduction.lean","15","theorem","main_reduction","theorem main_reduction {f H W E : Complex -> Complex} (hAB : RiemannHypothesis f -> HerglotzOnUpperHalfPlane H) (hBA : HerglotzOnUpperHalfPlane H -> RiemannHypothesis f) (hBC : HerglotzOnUpperHalfPlane H -> SchurOnUpperHalfPlane W) (hCB : SchurOnUpperHalfPlane W -> HerglotzOnUpperHalfPlane H) (hBD : HerglotzOnUpperHalfPlane H -> KernelPSDOnUpper (pickKernelH H)) (hDB : KernelPSDOnUpper (pickKernelH H) -> HerglotzOnUpperHalfPlane H) (hCE : SchurOnUpperHalfPlane W -> DeBrangesKernelPositiveSemidefinite E) (hEC : DeBrangesKernelPositiveSemidefinite E -> SchurOnUpperHalfPlane W) (hBF : HerglotzOnUpperHalfPlane H -> CanonicalSystemGlobalJContractive H) (hFB : CanonicalSystemGlobalJContractive H -> HerglotzOnUpperHalfPlane H) : (RiemannHypothesis f <-> HerglotzOnUpperHalfPlane H) /\ (HerglotzOnUpperHalfPlane H <-> SchurOnUpperHalfPlane W) /\ (HerglotzOnUpperHalfPlane H <-> KernelPSDOnUpper (pickKernelH H)) /\ (SchurOnUpperHalfPlane W <-> DeBrangesKernelPositiveSemidefinite E) /\ (HerglotzOnUpperHalfPlane H <-> CanonicalSystemGlobalJContractive H) := by"
"MArithChartDerivative.lean","11","theorem","m_arith_chart_derivative","theorem m_arith_chart_derivative {z : Complex} (hArithModel : ArithStieltjesModelAt z) (hBridge : ArithStieltjesModelAt z -> ArithChartDerivativeAt z) : ArithChartDerivativeAt z := by"
"MeasureIdentity.lean","18","theorem","measure_identity_from_m_core","theorem measure_identity_from_m_core {mWeyl mArith : Complex -> Complex} {muWeyl muArith : Measure Real} (hmEq : cUpper.EqOn mWeyl mArith) (hRepWeyl : HasStieltjesRep mWeyl muWeyl) (hRepArith : HasStieltjesRep mArith muArith) (hRepCongr : forall {m1 m2 : Complex -> Complex} {mu : Measure Real}, cUpper.EqOn m1 m2 -> HasStieltjesRep m1 mu -> HasStieltjesRep m2 mu) (hUnique : forall {mu1 mu2 : Measure Real}, HasStieltjesRep mArith mu1 -> HasStieltjesRep mArith mu2 -> mu1 = mu2) : muWeyl = muArith := by"
"MeasureIdentity.lean","35","theorem","measure_identity_from_m","theorem measure_identity_from_m {mWeyl mArith : Complex -> Complex} {muWeyl muArith : Measure Real} (hmEq : cUpper.EqOn mWeyl mArith) (hRepWeyl : HasStieltjesRep mWeyl muWeyl) (hRepArith : HasStieltjesRep mArith muArith) (hRepCongr : forall {m1 m2 : Complex -> Complex} {mu : Measure Real}, cUpper.EqOn m1 m2 -> HasStieltjesRep m1 mu -> HasStieltjesRep m2 mu) (hUnique : forall {mu1 mu2 : Measure Real}, HasStieltjesRep mArith mu1 -> HasStieltjesRep mArith mu2 -> mu1 = mu2) : muWeyl = muArith := by"
"MobiusHerglotzB21.lean","13","theorem","mobius_herglotz","theorem mobius_herglotz {zeta : Complex} {M : Complex -> Complex} {T : Complex -> Complex} {m : Nat -> Complex -> Complex} (hIm : UpperHalfPlanePoint zeta) (hJContractive : JContractiveAt zeta M) (hMobiusBridge : UpperHalfPlanePoint zeta -> JContractiveAt zeta M -> MapsUpperHalfPlaneToItself T) (hIterBridge : MapsUpperHalfPlaneToItself T -> TruncationWeylHerglotzFamily m) : MapsUpperHalfPlaneToItself T /\ TruncationWeylHerglotzFamily m := by"
"NoPoleNevanlinna.lean","12","theorem","no_pole_nevanlinna","theorem no_pole_nevanlinna {f H : Complex -> Complex} (hNevanlinnaBridge : StripPoleExclusionViaNevanlinna f H) : StripPoleExclusionViaNevanlinna f H := by"
"NoZerosFromHerglotz.lean","9","theorem","no_zeros_from_herglotz","theorem no_zeros_from_herglotz {f H : Complex -> Complex} (hHerglotz : HerglotzOnUpperHalfPlane H) (hNevanlinnaExclusion : StripPoleExclusionViaNevanlinna f H) : ZeroFreeOnUpper f := by"
"PGLCross.lean","13","theorem","PGL_cross","theorem PGL_cross {z : Complex} (hForward : R2PGLMapEqualityAt z -> R2PGLCrossCancelIdentityAt z) (hBackward : R2PGLCrossCancelIdentityAt z -> R2PGLMapEqualityAt z) : R2PGLMapEqualityAt z <-> R2PGLCrossCancelIdentityAt z := by"
"PickHerglotz.lean","20","theorem","pick_herglotz","theorem pick_herglotz {H : Complex -> Complex} (hHol : HolomorphicOnUpperHalfPlane H) (hForward : HerglotzOnUpperHalfPlane H -> KernelPSDOnUpper (pickKernelH H)) (hBackward : KernelPSDOnUpper (pickKernelH H) -> HerglotzOnUpperHalfPlane H) : HerglotzOnUpperHalfPlane H <-> KernelPSDOnUpper (pickKernelH H) := by"
"PickKernelCompressionB21.lean","11","theorem","pick_kernel_compression","theorem pick_kernel_compression (hCompression : forall (n : Nat), RankOneCompressionFormulaAtLevel n) (hPsdTransfer : (forall (n : Nat), MatrixPickKernelPSDAtLevel n) -> (forall (n : Nat), RankOneCompressionFormulaAtLevel n) -> forall (n : Nat), ScalarPickKernelPSDAtLevel n) (hMatrixPsd : forall (n : Nat), MatrixPickKernelPSDAtLevel n) : (forall (n : Nat), RankOneCompressionFormulaAtLevel n) /\ (forall (n : Nat), ScalarPickKernelPSDAtLevel n) := by"
"PickKernelTwoSides.lean","11","theorem","pick_kernel_two_sides","theorem pick_kernel_two_sides {z : Complex} (hArithStieltjes : ArithStieltjesModelAt z) (hKernelMatch : CalibKernelMatchAt z) (hBridge : ArithStieltjesModelAt z -> CalibKernelMatchAt z -> PickKernelTwoSidesAt z) : PickKernelTwoSidesAt z := by"
"PickSchur.lean","13","theorem","pick_schur","theorem pick_schur {W : Complex -> Complex} (hHol : HolomorphicOnUpperHalfPlane W) (hForward : SchurOnUpperHalfPlane W -> KernelPSDOnUpper (pickKernelW W)) (hBackward : KernelPSDOnUpper (pickKernelW W) -> SchurOnUpperHalfPlane W) : SchurOnUpperHalfPlane W <-> KernelPSDOnUpper (pickKernelW W) := by"
"PolarizedJKernelB21.lean","15","theorem","polarized_J_kernel","theorem polarized_J_kernel {M R H : Complex -> Complex} (hFormula : forall (zeta omega : Complex), InUpperB21 zeta -> InUpperB21 omega -> PolarizedEnergyIdentityAt zeta omega M R H) (hPosBridge : (forall (zeta omega : Complex), InUpperB21 zeta -> InUpperB21 omega -> PolarizedEnergyIdentityAt zeta omega M R H) -> PolarizedKernelPSDOnUpper M R H) : (forall (zeta omega : Complex), InUpperB21 zeta -> InUpperB21 omega -> PolarizedEnergyIdentityAt zeta omega M R H) /\ PolarizedKernelPSDOnUpper M R H := by"
"R0JetPinning.lean","13","theorem","R0_jet_pinning","theorem R0_jet_pinning {z : Complex} (hJetData : R2R0JetDataAt z) (hJetBridge : R2R0JetDataAt z -> R2R0JetPinnedAt z) : R2R0JetPinnedAt z := by"
"R0JetSchurForm.lean","11","theorem","R0_jet_schur_form","theorem R0_jet_schur_form {z : Complex} (hJetPinned : R2R0JetPinnedAt z) (hSchurBridge : R2R0JetPinnedAt z -> R2R0JetSchurFormAt z) : R2R0JetSchurFormAt z := by"
"R1AtomicAggregateDetExpansion.lean","11","theorem","R1_atomic_aggregate_det_expansion","theorem R1_atomic_aggregate_det_expansion {z : Complex} (hAtomicBridge : R1AggregateDetExpansionAt z -> R1AtomicAggregateDetExpansionAt z) (hExpansion : R1AggregateDetExpansionAt z) : R1AtomicAggregateDetExpansionAt z := by"
"R1BoundedKjImpliesFiniteMass.lean","14","theorem","R1_bounded_Kj_implies_finite_mass","theorem R1_bounded_Kj_implies_finite_mass {z : Complex} (hBottleneck : forall j : Nat, R1PrefixTraceKappaBottleneckAt j z) (hKjBounded : R1KjUniformBoundOnSubseqAt z) (hFiniteMassBridge : (forall j : Nat, R1PrefixTraceKappaBottleneckAt j z) -> R1KjUniformBoundOnSubseqAt z -> R1FiniteTotalMassByBoundedKjAt z) : R1FiniteTotalMassByBoundedKjAt z := by"
"R1CircleEq.lean","16","theorem","R1_circle_eq","theorem R1_circle_eq {n : Nat} {z : Complex} (hz : InUpperB21 z) (hMembership : R1MembershipIdentityAvailable n z) (hBoundaryBridge : InUpperB21 z -> R1MembershipIdentityAvailable n z -> forall m : Complex, OnWeylBoundary n z m <-> SatisfiesWeylCircleEq n z m) : forall m : Complex, OnWeylBoundary n z m <-> SatisfiesWeylCircleEq n z m := by"
"R1ClassicalMass.lean","13","theorem","R1_classical_mass","theorem R1_classical_mass {z : Complex} (hMassDiverges : R1TotalMassDivergesAt z) (hClassicalBridge : R1TotalMassDivergesAt z -> R1ClassicalMassCriterionAt z) : R1ClassicalMassCriterionAt z := by"
"R1ClassicalMassApplicability.lean","15","theorem","R1_classical_mass_applicability","theorem R1_classical_mass_applicability {z : Complex} (hPSD : R1ChainBlockPSDAt z) (hStep : R1CanonicalStepModelAt z) (hWeyl : R1WeylDiskRadiusModelAt z) (hEnergy : UpperHalfPlanePoint z -> True) (hApplicabilityBridge : R1ChainBlockPSDAt z -> R1CanonicalStepModelAt z -> R1WeylDiskRadiusModelAt z -> (UpperHalfPlanePoint z -> True) -> R1ClassicalMassApplicabilityAt z) : R1ClassicalMassApplicabilityAt z := by"
"R1CollapseAtomicSymplOrth.lean","13","theorem","R1_collapse_atomic_sympl_orth","theorem R1_collapse_atomic_sympl_orth {z : Complex} (hMassDiverges : R1TotalMassDivergesAt z) (hAtomicCS2Target : R1CS2OnRadiusfloorTargetAt z) (hFiniteMassBridge : R1CS2OnRadiusfloorTargetAt z -> R1FiniteTotalMassAt z) (hCollapseBridge : R1TotalMassDivergesAt z -> R1FiniteTotalMassAt z -> R1GlobalRadiusCollapseAt z) : R1GlobalRadiusCollapseAt z := by"
"R1CollapseCollinearVisible.lean","12","theorem","R1_collapse_collinear_visible","theorem R1_collapse_collinear_visible {z : Complex} (hMassDiverges : R1TotalMassDivergesAt z) (hCollinearPrefixBound : R1PrefixMassCollinearVisibleBoundAt z) (hPrincipleBridge : R1TotalMassDivergesAt z -> R1PrefixMassCollinearVisibleBoundAt z -> R1GlobalRadiusCollapseFromCollinearAt z) : R1GlobalRadiusCollapseFromCollinearAt z := by"
"R1CollapseDetfloorTracecap.lean","12","theorem","R1_collapse_detfloor_tracecap","theorem R1_collapse_detfloor_tracecap {z : Complex} (hDetfloorTracecap : R1GlobalDetfloorTracecapAt z) (hToGlobalSpd : R1GlobalDetfloorTracecapAt z -> R1GlobalUniformSpdFloorAt z) (hCollapseFromSpd : R1GlobalUniformSpdFloorAt z -> R1GlobalRadiusCollapseAt z) : R1GlobalRadiusCollapseAt z := by"
"R1CollapseDetZeroAggregate.lean","13","theorem","R1_collapse_det_zero_aggregate","theorem R1_collapse_det_zero_aggregate {z : Complex} (hMassDiverges : R1TotalMassDivergesAt z) (hDetZero : R1AggregateDetZeroCriterionAt z) (hDetEquiv : R1RankOneAggregateCriterionAt z <-> R1AggregateDetZeroCriterionAt z) (hRankOneToPrefix : R1RankOneAggregateCriterionAt z -> R1PrefixMassBoundFromRank1AggregateAt z) (hRankOneCollapseBridge : R1TotalMassDivergesAt z -> R1PrefixMassBoundFromRank1AggregateAt z -> R1GlobalCollapseFromRank1AggregateAt z) (hFinalize : R1GlobalCollapseFromRank1AggregateAt z -> R1CollapseDetZeroAggregateAt z) : R1CollapseDetZeroAggregateAt z := by"
"R1CollapseInvtracecap.lean","12","theorem","R1_collapse_invtracecap","theorem R1_collapse_invtracecap {z : Complex} (hInvtraceCap : R1GlobalInvtraceCapAt z) (hToGlobalSpd : R1GlobalInvtraceCapAt z -> R1GlobalUniformSpdFloorAt z) (hCollapseFromSpd : R1GlobalUniformSpdFloorAt z -> R1GlobalRadiusCollapseAt z) : R1GlobalRadiusCollapseAt z := by"
"R1CollapseRank1Aggregate.lean","13","theorem","R1_collapse_rank1_aggregate","theorem R1_collapse_rank1_aggregate {z : Complex} (hMassDiverges : R1TotalMassDivergesAt z) (hPrefixBound : R1PrefixMassBoundFromRank1AggregateAt z) (hCollapseBridge : R1TotalMassDivergesAt z -> R1PrefixMassBoundFromRank1AggregateAt z -> R1GlobalCollapseFromRank1AggregateAt z) : R1GlobalCollapseFromRank1AggregateAt z := by"
"R1CollapseSpdFloor.lean","14","theorem","R1_collapse_spd_floor","theorem R1_collapse_spd_floor {z : Complex} (hGlobalSpdFloor : R1GlobalUniformSpdFloorAt z) (hSpdToCS2Target : R1GlobalUniformSpdFloorAt z -> R1CS2OnRadiusfloorTargetAt z) (hFiniteMassBridge : R1CS2OnRadiusfloorTargetAt z -> R1FiniteTotalMassAt z) (hMassDivergesFromSpd : R1GlobalUniformSpdFloorAt z -> R1TotalMassDivergesAt z) (hCollapseBridge : R1TotalMassDivergesAt z -> R1FiniteTotalMassAt z -> R1GlobalRadiusCollapseAt z) : R1GlobalRadiusCollapseAt z := by"
"R1CollapseUniformEllipticTracefloor.lean","12","theorem","R1_collapse_uniform_elliptic_tracefloor","theorem R1_collapse_uniform_elliptic_tracefloor {z : Complex} (hUniformEllipticTracefloor : R1GlobalUniformEllipticTracefloorAt z) (hToGlobalSpd : R1GlobalUniformEllipticTracefloorAt z -> R1GlobalUniformSpdFloorAt z) (hCollapseFromSpd : R1GlobalUniformSpdFloorAt z -> R1GlobalRadiusCollapseAt z) : R1GlobalRadiusCollapseAt z := by"
"R1CollinearFromRank1Aggregate.lean","13","theorem","R1_collinear_from_rank1_aggregate","theorem R1_collinear_from_rank1_aggregate {z : Complex} (hAggregate : R1Rank1AggregateWindowAt z) (hCollinearBridge : R1Rank1AggregateWindowAt z -> R1CollinearRepresentationFromAggregateAt z) : R1CollinearRepresentationFromAggregateAt z := by"
"R1CS2AtomicSymplOrthWindows.lean","12","theorem","R1_CS2_atomic_sympl_orth_windows","theorem R1_CS2_atomic_sympl_orth_windows {z : Complex} (hAtomicExpansion : R1AtomicAggregateDetExpansionAt z) (hAtomicOrth : R1AtomicSymplOrthWindowFamilyAt z) (hDetZeroBridge : R1AtomicAggregateDetExpansionAt z -> R1AtomicSymplOrthWindowFamilyAt z -> R1AggregateDetZeroCriterionAt z) (hDetZeroCS2 : R1AggregateDetZeroCriterionAt z -> R1CS2OnRadiusfloorTargetAt z) : R1CS2OnRadiusfloorTargetAt z := by"
"R1CS2CollinearWindows.lean","12","theorem","R1_CS2_collinear_windows","theorem R1_CS2_collinear_windows {z : Complex} (hRadiusFloor : R1RadiusFloorTargetSubsequenceAt z) (hCollinear : R1CollinearWindowModelAt z) (hPrefixBridge : R1RadiusFloorTargetSubsequenceAt z -> R1CollinearWindowModelAt z -> R1PrefixMassCollinearVisibleBoundAt z) (hPrefixToDirect : R1PrefixMassCollinearVisibleBoundAt z -> R1PrefixWindowDirectBoundAt z) (hForward : R1TailWindowBoundOnSubseqAt z -> R1PrefixWindowDirectBoundAt z) (hBackward : R1PrefixWindowDirectBoundAt z -> R1TailWindowBoundOnSubseqAt z) (hTailToStructured : R1TailWindowBoundOnSubseqAt z -> R1StructuredTailWindowBoundAt z) (hLineBridge : R1CollinearWindowModelAt z -> R1WindowLagrangianLineAt z) (hOrthBridge : R1WindowLagrangianLineAt z -> R1WindowSymplecticOrthAt z) (hStructuredBridge : R1StructuredTailWindowBoundAt z -> R1WindowSymplecticOrthAt z -> R1CS2StructuredBoundAt z) (hStructuredToCS2 : R1CS2StructuredBoundAt z -> R1CS2ConditionAt z) (hTargetBridge : R1CS2ConditionAt z -> R1CS2OnRadiusfloorTargetAt z) : R1CS2OnRadiusfloorTargetAt z := by"
"R1CS2DetfloorTracecap.lean","12","theorem","R1_CS2_detfloor_tracecap","theorem R1_CS2_detfloor_tracecap {z : Complex} (hCondition : R1DetfloorTracecapConditionAt z) (hToSpdFloor : R1DetfloorTracecapConditionAt z -> R1UniformSPDFloorOnWindowsAt z) (hSpdToTarget : R1UniformSPDFloorOnWindowsAt z -> R1CS2OnRadiusfloorTargetAt z) : R1CS2OnRadiusfloorTargetAt z := by"
"R1CS2DetZeroAggregate.lean","9","theorem","R1_CS2_det_zero_aggregate","theorem R1_CS2_det_zero_aggregate {z : Complex} (hDetZero : R1AggregateDetZeroCriterionAt z) (hDetEquiv : R1RankOneAggregateCriterionAt z <-> R1AggregateDetZeroCriterionAt z) (hCriterionToWindow : R1RankOneAggregateCriterionAt z -> R1Rank1AggregateWindowAt z) (hRankOneCS2 : R1Rank1AggregateWindowAt z -> R1CS2OnRadiusfloorTargetAt z) : R1CS2OnRadiusfloorTargetAt z := by"
"R1CS2Equiv.lean","11","theorem","R1_CS2_equiv","theorem R1_CS2_equiv {z : Complex} (hCS2 : R1CS2ConditionAt z) (hDet1 : forall n : Nat, R1TruncationTransferDetOneAt n z) (hSingularBridge : R1CS2ConditionAt z -> (forall n : Nat, R1TruncationTransferDetOneAt n z) -> R1CS2SingularValueCharacterAt z) (hTailBridge : R1CS2SingularValueCharacterAt z -> (R1CS2ConditionAt z <-> R1CS2TailBoundAt z)) : R1CS2SingularValueCharacterAt z /\ (R1CS2ConditionAt z <-> R1CS2TailBoundAt z) := by"
"R1CS2EquivKj.lean","8","theorem","R1_CS2_equiv_Kj","theorem R1_CS2_equiv_Kj {z : Complex} (hForward : R1CS2ConditionAt z -> R1KjUniformBoundAt z) (hBackward : R1KjUniformBoundAt z -> R1CS2ConditionAt z) : R1CS2ConditionAt z <-> R1KjUniformBoundAt z := by"
"R1CS2FailureForcesVanishingCoercivity.lean","14","theorem","R1_CS2_failure_forces_vanishing_coercivity","theorem R1_CS2_failure_forces_vanishing_coercivity {z : Complex} (hFailure : R1CS2FailureOnRadiusfloorTargetAt z) (hSpdFloorImpliesCS2 : R1UniformSPDFloorOnWindowsAt z -> R1CS2OnRadiusfloorTargetAt z) (hContrapositiveBridge : (R1UniformSPDFloorOnWindowsAt z -> R1CS2OnRadiusfloorTargetAt z) -> R1CS2FailureOnRadiusfloorTargetAt z -> R1LocalCoercivityInfimumZeroAt z) : R1LocalCoercivityInfimumZeroAt z := by"
"R1CS2FailureForcesVanishingFrameCoercivity.lean","15","theorem","R1_CS2_failure_forces_vanishing_frame_coercivity","theorem R1_CS2_failure_forces_vanishing_frame_coercivity {z : Complex} (hFailure : R1CS2FailureOnRadiusfloorTargetAt z) (hCoercivityImpliesCS2 : R1FrameCoercivityWindowConditionAt z -> R1CS2OnRadiusfloorTargetAt z) (hContrapositiveBridge : (R1FrameCoercivityWindowConditionAt z -> R1CS2OnRadiusfloorTargetAt z) -> R1CS2FailureOnRadiusfloorTargetAt z -> R1FrameCoercivityInfimumZeroAt z) : R1FrameCoercivityInfimumZeroAt z := by"
"R1CS2FailureForcesVanishingMaxindexFrameCoercivity.lean","13","theorem","R1_CS2_failure_forces_vanishing_maxindex_frame_coercivity","theorem R1_CS2_failure_forces_vanishing_maxindex_frame_coercivity {z : Complex} (hFailure : R1CS2FailureOnRadiusfloorTargetAt z) (hMaxindexImpliesCS2 : R1MaxindexFrameCoercivityConditionAt z -> R1CS2OnRadiusfloorTargetAt z) (hContrapositiveBridge : (R1MaxindexFrameCoercivityConditionAt z -> R1CS2OnRadiusfloorTargetAt z) -> R1CS2FailureOnRadiusfloorTargetAt z -> R1MaxindexFrameCoercivityInfimumZeroAt z) : R1MaxindexFrameCoercivityInfimumZeroAt z := by"
"R1CS2FrameCoercivityWindows.lean","13","theorem","R1_CS2_frame_coercivity_windows","theorem R1_CS2_frame_coercivity_windows {z : Complex} (hBalance : R1FrameRatioKappaBalanceAt z) (hCoercivity : R1FrameCoercivityWindowConditionAt z) (hCS2Bridge : R1FrameRatioKappaBalanceAt z -> R1FrameCoercivityWindowConditionAt z -> R1CS2ConditionAt z) (hTargetBridge : R1CS2ConditionAt z -> R1CS2OnRadiusfloorTargetAt z) : R1CS2OnRadiusfloorTargetAt z := by"
"R1CS2FromFiniteTotalMass.lean","10","theorem","R1_CS2_from_finite_total_mass","theorem R1_CS2_from_finite_total_mass {z : Complex} (hFiniteMass : R1FiniteTotalMassAt z) (hTailBridge : R1FiniteTotalMassAt z -> R1CS2TailBoundAt z) (hTailToCS2 : R1CS2TailBoundAt z -> R1CS2ConditionAt z) (hFinalize : R1CS2TailBoundAt z -> R1CS2ConditionAt z -> R1CS2FromFiniteTotalMassAt z) : R1CS2FromFiniteTotalMassAt z := by"
"R1CS2FromMaxindexFrameCoercivity.lean","14","theorem","R1_CS2_from_maxindex_frame_coercivity","theorem R1_CS2_from_maxindex_frame_coercivity {z : Complex} (hBalance : R1FrameRatioKappaBalanceAt z) (hMaxindexCoercivity : R1MaxindexFrameCoercivityConditionAt z) (hKjBridge : R1FrameRatioKappaBalanceAt z -> R1MaxindexFrameCoercivityConditionAt z -> R1KjUniformBoundAt z) (hCS2EquivKj : R1CS2ConditionAt z <-> R1KjUniformBoundAt z) (hTargetBridge : R1CS2ConditionAt z -> R1CS2OnRadiusfloorTargetAt z) : R1CS2OnRadiusfloorTargetAt z := by"
"R1CS2Invtracecap.lean","13","theorem","R1_CS2_invtracecap","theorem R1_CS2_invtracecap {z : Complex} (hInvTraceCap : R1InverseTraceCapConditionAt z) (hToSpdFloor : R1InverseTraceCapConditionAt z -> R1UniformSPDFloorOnWindowsAt z) (hSpdToTarget : R1UniformSPDFloorOnWindowsAt z -> R1CS2OnRadiusfloorTargetAt z) : R1CS2OnRadiusfloorTargetAt z := by"
"R1CS2OnRadiusfloorTarget.lean","11","theorem","R1_CS2_on_radiusfloor_target","theorem R1_CS2_on_radiusfloor_target {z : Complex} (hRadiusFloor : R1RadiusFloorTargetSubsequenceAt z) (hRadiusfloorClosure : R1RadiusFloorTargetSubsequenceAt z -> R1RadiusfloorClosurePrefixBoundAt z /\ R1TailWindowBoundOnSubseqAt z) (hFiniteFromClosure : R1RadiusfloorClosurePrefixBoundAt z /\ R1TailWindowBoundOnSubseqAt z -> R1FiniteTotalMassAt z) (hCS2FromFiniteMass : R1FiniteTotalMassAt z -> R1CS2ConditionAt z) (hTargetBridge : R1CS2ConditionAt z -> R1CS2OnRadiusfloorTargetAt z) : R1CS2OnRadiusfloorTargetAt z := by"
"R1CS2Rank1Aggregate.lean","9","theorem","R1_CS2_rank1_aggregate","theorem R1_CS2_rank1_aggregate {z : Complex} (hRankOneAggregate : R1Rank1AggregateWindowAt z) (hCollinearBridge : R1Rank1AggregateWindowAt z -> R1CollinearRepresentationFromAggregateAt z) (hModelBridge : R1CollinearRepresentationFromAggregateAt z -> R1CollinearWindowModelAt z) (hCollinearCS2 : R1CollinearWindowModelAt z -> R1CS2OnRadiusfloorTargetAt z) : R1CS2OnRadiusfloorTargetAt z := by"
"R1CS2SpdFloor.lean","16","theorem","R1_CS2_spd_floor","theorem R1_CS2_spd_floor {z : Complex} (hRadiusFloor : R1RadiusFloorSubsequenceAt z) (hSpdFloor : R1UniformSPDFloorOnWindowsAt z) (hBottleneck : (forall j : Nat, R1PrefixTraceKappaBottleneckAt j z) /\ R1FrameGrowthDivergenceAt z) (hDet1 : forall n : Nat, R1TruncationTransferDetOneAt n z) (hCS2Equiv : R1CS2ConditionAt z <-> R1CS2TailBoundAt z) (hSpdBridge : R1RadiusFloorSubsequenceAt z -> R1UniformSPDFloorOnWindowsAt z -> ((forall j : Nat, R1PrefixTraceKappaBottleneckAt j z) /\ R1FrameGrowthDivergenceAt z) -> (forall n : Nat, R1TruncationTransferDetOneAt n z) -> (R1CS2ConditionAt z <-> R1CS2TailBoundAt z) -> R1CS2ConditionAt z) (hTargetBridge : R1CS2ConditionAt z -> R1CS2SpdFloorAt z) : R1CS2SpdFloorAt z := by"
"R1CS2StructuredLagrangianLine.lean","12","theorem","R1_CS2_structured_lagrangian_line","theorem R1_CS2_structured_lagrangian_line {z : Complex} (hLagrangianLine : R1WindowLagrangianLineAt z) (hOrthBridge : R1WindowLagrangianLineAt z -> R1WindowSymplecticOrthAt z) (hStructuredBridge : R1StructuredTailWindowBoundAt z -> R1WindowSymplecticOrthAt z -> R1CS2StructuredBoundAt z) (hTailWindow : R1StructuredTailWindowBoundAt z) : R1WindowSymplecticOrthAt z /\ R1CS2StructuredBoundAt z := by"
"R1CS2StructuredLinear.lean","16","theorem","R1_CS2_structured_linear","theorem R1_CS2_structured_linear {z : Complex} (hTailWindow : R1StructuredTailWindowBoundAt z) (hWindowOrth : R1WindowSymplecticOrthAt z) (hLinearBridge : R1StructuredTailWindowBoundAt z -> R1WindowSymplecticOrthAt z -> R1CS2StructuredTailBoundAt z) (hCS2Bridge : R1CS2StructuredTailBoundAt z -> R1CS2StructuredBoundAt z) : R1CS2StructuredTailBoundAt z /\ R1CS2StructuredBoundAt z := by"
"R1CS2TailMassWindow.lean","12","theorem","R1_CS2_tail_mass_window","theorem R1_CS2_tail_mass_window {z : Complex} (hz : InUpperB21 z) (hTailWindow : R1TailWindowBoundAt z) (hRankOneTail : R1RankOneTailBranchAt z) (hStepLinear : forall k : Nat, R1Rank1StepLinearAt k z) (hTailBridge : InUpperB21 z -> R1TailWindowBoundAt z -> R1RankOneTailBranchAt z -> (forall k : Nat, R1Rank1StepLinearAt k z) -> R1CS2TailBoundAt z) (hCS2Bridge : R1CS2TailBoundAt z -> R1CS2ConditionAt z) : R1CS2TailBoundAt z /\ R1CS2ConditionAt z := by"
"R1CS2TailMassWindowSector.lean","11","theorem","R1_CS2_tail_mass_window_sector","theorem R1_CS2_tail_mass_window_sector {z : Complex} (hz : InUpperB21 z) (hSector : R1NonnegativeReZ2Sector z) (hTailWindow : R1TailWindowBoundAt z) (hStepBound : forall k : Nat, R1GeneralStepInverseBoundAt k z) (hTailBridge : InUpperB21 z -> R1NonnegativeReZ2Sector z -> R1TailWindowBoundAt z -> (forall k : Nat, R1GeneralStepInverseBoundAt k z) -> R1CS2TailBoundAt z) (hCS2Bridge : R1CS2TailBoundAt z -> R1CS2ConditionAt z) : R1CS2TailBoundAt z /\ R1CS2ConditionAt z := by"
"R1CS2UniformEllipticTracefloor.lean","13","theorem","R1_CS2_uniform_elliptic_tracefloor","theorem R1_CS2_uniform_elliptic_tracefloor {z : Complex} (hCondition : R1UniformEllipticTracefloorConditionAt z) (hToSpdFloor : R1UniformEllipticTracefloorConditionAt z -> R1UniformSPDFloorOnWindowsAt z) (hSpdToTarget : R1UniformSPDFloorOnWindowsAt z -> R1CS2OnRadiusfloorTargetAt z) : R1CS2OnRadiusfloorTargetAt z := by"
"R1CS2ZeroSymplAreaSum.lean","13","theorem","R1_CS2_zero_sympl_area_sum","theorem R1_CS2_zero_sympl_area_sum {z : Complex} (hExpansion : R1AggregateDetExpansionAt z) (hZeroSymplSum : R1ZeroSymplAreaSumOnWindowsAt z) (hZeroSumToDetZero : R1AggregateDetExpansionAt z -> R1ZeroSymplAreaSumOnWindowsAt z -> R1AggregateDetZeroCriterionAt z) (hDetZeroCS2 : R1AggregateDetZeroCriterionAt z -> R1CS2OnRadiusfloorTargetAt z) : R1CS2OnRadiusfloorTargetAt z := by"
"R1Det1.lean","11","theorem","R1_det1","theorem R1_det1 {z : Complex} (hStepDetOne : forall k : Nat, R1StepTransferDetOneAt k z) (hProductBridge : (forall k : Nat, R1StepTransferDetOneAt k z) -> forall n : Nat, R1TruncationTransferDetOneAt n z) : (forall k : Nat, R1StepTransferDetOneAt k z) /\ (forall n : Nat, R1TruncationTransferDetOneAt n z) := by"
"R1DetQ.lean","10","theorem","R1_detQ","theorem R1_detQ {z : Complex} (hz : InUpperB21 z) (hDet1 : forall n : Nat, R1TruncationTransferDetOneAt n z) (hDetBridge : InUpperB21 z -> (forall n : Nat, R1TruncationTransferDetOneAt n z) -> forall n : Nat, R1CircleMatrixDetFixedAt n z) : forall n : Nat, R1CircleMatrixDetFixedAt n z := by"
"R1DetZeroForcesSymplOrthPairs.lean","13","theorem","R1_det_zero_forces_sympl_orth_pairs","theorem R1_det_zero_forces_sympl_orth_pairs {z : Complex} (hExpansion : R1AggregateDetExpansionAt z) (hDetZero : R1AggregateDetZeroAt z) (hBridge : R1AggregateDetExpansionAt z -> R1AggregateDetZeroAt z -> R1PairwiseSymplOrthCouplingZeroAt z) : R1PairwiseSymplOrthCouplingZeroAt z := by"
"R1EnergyCoercive.lean","20","theorem","R1_energy_coercive","theorem R1_energy_coercive {z : Complex} (hz : InUpperB21 z) (hRadiusEnergy : forall n : Nat, R1RadiusEnergyIdentityAt n z) (hCoercive : forall n : Nat, R1EnergyCoerciveAssumptionAt n z) (hBoundBridge : InUpperB21 z -> (forall n : Nat, R1RadiusEnergyIdentityAt n z) -> (forall n : Nat, R1EnergyCoerciveAssumptionAt n z) -> forall n : Nat, R1RadiusUpperBoundAt n z) (hCollapseBridge : (forall n : Nat, R1RadiusUpperBoundAt n z) -> R1MassDivergenceAt z -> R1RadiusCollapseAt z) : (forall n : Nat, R1RadiusUpperBoundAt n z) /\ (R1MassDivergenceAt z -> R1RadiusCollapseAt z) := by"
"R1FrameRatioKappaBalance.lean","14","theorem","R1_frame_ratio_kappa_balance","theorem R1_frame_ratio_kappa_balance {z : Complex} (hRadiusFloor : R1RadiusFloorSubsequenceAt z) (hBottleneck : (forall j : Nat, R1PrefixTraceKappaBottleneckAt j z) /\ R1FrameGrowthDivergenceAt z) (hDet1 : forall n : Nat, R1TruncationTransferDetOneAt n z) (hCS2Equiv : R1CS2ConditionAt z <-> R1CS2TailBoundAt z) (hBalanceBridge : R1RadiusFloorSubsequenceAt z -> ((forall j : Nat, R1PrefixTraceKappaBottleneckAt j z) /\ R1FrameGrowthDivergenceAt z) -> (forall n : Nat, R1TruncationTransferDetOneAt n z) -> (R1CS2ConditionAt z <-> R1CS2TailBoundAt z) -> R1FrameRatioKappaBalanceAt z) : R1FrameRatioKappaBalanceAt z := by"
"R1GeneralStepInverseBoundSector.lean","13","theorem","R1_general_step_inverse_bound_sector","theorem R1_general_step_inverse_bound_sector {z : Complex} (hz : InUpperB21 z) (hSector : R1NonnegativeReZ2Sector z) (hStepBridge : InUpperB21 z -> R1NonnegativeReZ2Sector z -> forall k : Nat, R1GeneralStepInverseBoundAt k z) : forall k : Nat, R1GeneralStepInverseBoundAt k z := by"
"R1JformNotCS2.lean","15","theorem","R1_Jform_not_CS2","theorem R1_Jform_not_CS2 {z : Complex} (hJInvariant : R1JformInvariantFamilyAt z) (hDistortion : R1FrameDistortionDivergesAt z) (hWitnessBridge : R1JformInvariantFamilyAt z -> R1FrameDistortionDivergesAt z -> R1JformControlNotEnoughForCS2At z) : R1JformInvariantFamilyAt z /\ R1FrameDistortionDivergesAt z /\ R1JformControlNotEnoughForCS2At z := by"
"R1KappaLowerFromPrefix.lean","10","theorem","R1_kappa_lower_from_prefix","theorem R1_kappa_lower_from_prefix {z : Complex} (hBottleneck : forall j : Nat, R1PrefixTraceKappaBottleneckAt j z) (hLowerBridge : (forall j : Nat, R1PrefixTraceKappaBottleneckAt j z) -> forall j : Nat, R1KappaLowerFromPrefixAt j z) : forall j : Nat, R1KappaLowerFromPrefixAt j z := by"
"R1KappaPointwiseTailExp.lean","11","theorem","R1_kappa_pointwise_tail_exp","theorem R1_kappa_pointwise_tail_exp {z : Complex} (hRankOneTail : R1RankOneTailBranchAt z) (hStepLinear : forall k : Nat, R1Rank1StepLinearAt k z) (hTailBridge : R1RankOneTailBranchAt z -> (forall k : Nat, R1Rank1StepLinearAt k z) -> forall k j : Nat, R1KappaPointwiseTailExpAt k j z) : forall k j : Nat, R1KappaPointwiseTailExpAt k j z := by"
"R1KappaTailExp.lean","14","theorem","R1_kappa_tail_exp","theorem R1_kappa_tail_exp {z : Complex} (hTailWindow : R1TailWindowBoundAt z) (hRankOneTail : R1RankOneTailBranchAt z) (hPointwiseBridge : R1TailWindowBoundAt z -> R1RankOneTailBranchAt z -> forall k j : Nat, R1KappaTailExpPointwiseAt k j z) (hFiniteMassToCS2Bridge : R1FiniteTotalMassForKappaAt z -> (forall k j : Nat, R1KappaTailExpPointwiseAt k j z) -> R1CS2ConditionAt z) : (forall k j : Nat, R1KappaTailExpPointwiseAt k j z) /\ (R1FiniteTotalMassForKappaAt z -> R1CS2ConditionAt z) := by"
"R1KjPrefixEquivRank1.lean","11","theorem","R1_Kj_prefix_equiv_rank1","theorem R1_Kj_prefix_equiv_rank1 {z : Complex} (hLowerBridge : (forall j : Nat, R1KappaLowerFromPrefixAt j z) -> R1PrefixMassUniformBoundAt z -> R1KjUniformBoundAt z) (hUpperBridge : (forall k j : Nat, R1KappaPointwiseTailExpAt k j z) -> R1KjUniformBoundAt z -> R1PrefixMassUniformBoundAt z) (hLower : forall j : Nat, R1KappaLowerFromPrefixAt j z) (hPointwise : forall k j : Nat, R1KappaPointwiseTailExpAt k j z) : (R1PrefixMassUniformBoundAt z -> R1KjUniformBoundAt z) /\ (R1KjUniformBoundAt z -> R1PrefixMassUniformBoundAt z) := by"
"R1LagrangeIdentityGlobal.lean","14","theorem","R1_lagrange_identity_global","theorem R1_lagrange_identity_global {z : Complex} (hz : InUpperB21 z) (hEnergy : forall n : Nat, R1EnergyNStepIdentityAt n z) (hLagrangeBridge : InUpperB21 z -> (forall n : Nat, R1EnergyNStepIdentityAt n z) -> forall n : Nat, R1LagrangeGlobalIdentityAt n z) (hMonotoneBridge : (forall n : Nat, R1LagrangeGlobalIdentityAt n z) -> forall n : Nat, R1LagrangeMonotoneAt n z) : (forall n : Nat, R1LagrangeGlobalIdentityAt n z) /\ (forall n : Nat, R1LagrangeMonotoneAt n z) := by"
"R1LimitCircleImpliesFiniteMass.lean","16","theorem","R1_limit_circle_implies_finite_mass","theorem R1_limit_circle_implies_finite_mass {z : Complex} (hLimitCircle : R1LimitCircleSubsequenceAt z) (hCS2 : R1CS2ConditionAt z) (hLagrange : forall n : Nat, R1LagrangeGlobalIdentityAt n z) (hTraceCompare : forall k j : Nat, R1TwoChannelTraceCompareAt k j z) (hTransport : forall k : Nat, R1TransportInvariantAt k z) (hDet1 : forall n : Nat, R1TruncationTransferDetOneAt n z) (hEnergyBridge : R1LimitCircleSubsequenceAt z -> (forall n : Nat, R1LagrangeGlobalIdentityAt n z) -> (forall k : Nat, R1TransportInvariantAt k z) -> R1TwoChannelEnergyBoundAt z) (hFiniteMassBridge : R1CS2ConditionAt z -> (forall k j : Nat, R1TwoChannelTraceCompareAt k j z) -> (forall n : Nat, R1TruncationTransferDetOneAt n z) -> R1TwoChannelEnergyBoundAt z -> R1FiniteTotalMassAt z) : R1TwoChannelEnergyBoundAt z /\ R1FiniteTotalMassAt z := by"
"R1LimitPoint.lean","15","theorem","R1_limit_point","theorem R1_limit_point {z : Complex} (hMassDiverges : R1TotalMassDivergesAt z) (hInternalCollapse : R1GlobalRadiusCollapseAt z) (hClassicalMass : R1ClassicalMassCriterionAt z) (hApplicability : R1ClassicalMassApplicabilityAt z) (hCollapseBridge : R1TotalMassDivergesAt z -> R1GlobalRadiusCollapseAt z -> R1ClassicalMassCriterionAt z -> R1ClassicalMassApplicabilityAt z -> R1LimitPointCollapseAt z) (hUniqueBridge : R1LimitPointCollapseAt z -> R1WeylLimitUniqueAt z) : R1LimitPointCollapseAt z /\ R1WeylLimitUniqueAt z := by"
"R1LinearTailUnderSymplecticOrth.lean","14","theorem","R1_linear_tail_under_symplectic_orth","theorem R1_linear_tail_under_symplectic_orth {z : Complex} (hStepInv : forall k : Nat, R1Rank1StepInverseLinearAt k z) (hOrth : forall p q : Nat, R1SymplecticOrthogonalityAt p q z) (hLinearTailBridge : (forall k : Nat, R1Rank1StepInverseLinearAt k z) -> (forall p q : Nat, R1SymplecticOrthogonalityAt p q z) -> forall k n : Nat, R1LinearTailFormulaAt k n z) (hNormBridge : (forall k n : Nat, R1LinearTailFormulaAt k n z) -> forall k n : Nat, R1LinearTailNormBoundAt k n z) : (forall k n : Nat, R1LinearTailFormulaAt k n z) /\ (forall k n : Nat, R1LinearTailNormBoundAt k n z) := by"
"R1MassDivergenceInternal.lean","14","theorem","R1_mass_divergence_internal","theorem R1_mass_divergence_internal {z : Complex} (hMassDiverges : R1TotalMassDivergesAt z) (hRadiusfloorClosure : R1RadiusFloorTargetSubsequenceAt z -> R1RadiusfloorClosurePrefixBoundAt z /\ R1TailWindowBoundOnSubseqAt z) (hInternalBridge : R1TotalMassDivergesAt z -> (R1RadiusFloorTargetSubsequenceAt z -> R1RadiusfloorClosurePrefixBoundAt z /\ R1TailWindowBoundOnSubseqAt z) -> R1MassDivergenceInternalAt z) (hCollapseBridge : R1MassDivergenceInternalAt z -> R1GlobalRadiusCollapseAt z) : R1MassDivergenceInternalAt z /\ R1GlobalRadiusCollapseAt z := by"
"R1MassDivergenceSelectsDivergentBranch.lean","9","theorem","R1_mass_divergence_selects_divergent_branch","theorem R1_mass_divergence_selects_divergent_branch {z : Complex} (hPrefixDiverges : R1PrefixMassDivergesAlongSubseqAt z) (hDichotomy : (R1BoundedBranchAt z \/ R1DivergentBranchAt z) /\ (R1BoundedBranchAt z -> R1DivergentBranchAt z -> False)) (hSelectBridge : R1PrefixMassDivergesAlongSubseqAt z -> ((R1BoundedBranchAt z \/ R1DivergentBranchAt z) /\ (R1BoundedBranchAt z -> R1DivergentBranchAt z -> False)) -> R1DivergentBranchAt z) (hConsequenceBridge : R1DivergentBranchAt z -> R1KjDivergesAt z /\ R1CS2FailsAt z) : R1DivergentBranchAt z /\ R1KjDivergesAt z /\ R1CS2FailsAt z := by"
"R1Membership.lean","12","theorem","R1_membership","theorem R1_membership {n : Nat} {z : Complex} (hz : InUpperB21 z) (hMembershipInput : R1MembershipIdentityAvailable n z) (hIdentityBridge : InUpperB21 z -> R1MembershipIdentityAvailable n z -> forall m : Complex, R1MembershipIdentityAt n z m) (hSignBridge : (forall m : Complex, R1MembershipIdentityAt n z m) -> forall m : Complex, R1DiskMembershipSignAgree n z m) (hBoundaryBridge : (forall m : Complex, R1MembershipIdentityAt n z m) -> forall m : Complex, OnWeylBoundary n z m <-> SatisfiesWeylCircleEq n z m) : (forall m : Complex, R1MembershipIdentityAt n z m) /\ (forall m : Complex, R1DiskMembershipSignAgree n z m) /\ (forall m : Complex, OnWeylBoundary n z m <-> SatisfiesWeylCircleEq n z m) := by"
"R1MinerrConv.lean","16","theorem","R1_minerr_conv","theorem R1_minerr_conv {z : Complex} (hCenterForm : forall n : Nat, R1DiskCenterFormAt n z) (hMinimax : forall n : Nat, R1MinimaxEqAt n z) (hErrorBridge : (forall n : Nat, R1DiskCenterFormAt n z) -> (forall n : Nat, R1MinimaxEqAt n z) -> forall n : Nat, R1CenterErrorBoundAt n z) (hConvBridge : (forall n : Nat, R1CenterErrorBoundAt n z) -> R1RadiusConvergesToZeroAt z -> R1CenterConvergesToLimitAt z) : (forall n : Nat, R1CenterErrorBoundAt n z) /\ (R1RadiusConvergesToZeroAt z -> R1CenterConvergesToLimitAt z) := by"
"R1Minimax.lean","15","theorem","R1_minimax","theorem R1_minimax {n : Nat} {z : Complex} (hRadius : R1RadiusFormulaAt n z) (hCenterBridge : R1RadiusFormulaAt n z -> R1DiskCenterFormAt n z) (hMinimaxBridge : R1DiskCenterFormAt n z -> R1RadiusFormulaAt n z -> R1MinimaxEqAt n z) (hUniqueBridge : R1MinimaxEqAt n z -> R1ChebyshevCenterUniqueAt n z) : R1DiskCenterFormAt n z /\ R1MinimaxEqAt n z /\ R1ChebyshevCenterUniqueAt n z := by"
"R1ObstructionCertificate.lean","14","theorem","R1_obstruction_certificate","theorem R1_obstruction_certificate {z : Complex} (hDivergenceBridge : R1PrefixMassDivergesAt z -> R1KjDivergesAt z) (hCS2FailBridge : R1KjDivergesAt z -> R1CS2FailsAt z) (hTailFailBridge : R1RankOneTailBranchAt z -> R1CS2FailsAt z -> R1TailWindowFailsAt z) (hRankOneTail : R1RankOneTailBranchAt z) : (R1PrefixMassDivergesAt z -> R1KjDivergesAt z) /\ (R1KjDivergesAt z -> R1CS2FailsAt z) /\ (R1CS2FailsAt z -> R1TailWindowFailsAt z) := by"
"R1OverlapReduction.lean","13","theorem","R1_overlap_reduction","theorem R1_overlap_reduction {z : Complex} (hNorm : forall n : Nat, R1OverlapNormBoundAt n z) (hAngle : forall n : Nat, R1OverlapAngleBoundAt n z) (hReductionBridge : (forall n : Nat, R1OverlapNormBoundAt n z) -> (forall n : Nat, R1OverlapAngleBoundAt n z) -> forall n : Nat, R1OverlapLowerBoundAt n z) (hCoerciveBridge : (forall n : Nat, R1OverlapLowerBoundAt n z) -> forall n : Nat, R1EnergyCoerciveAssumptionAt n z) : (forall n : Nat, R1OverlapLowerBoundAt n z) /\ (forall n : Nat, R1EnergyCoerciveAssumptionAt n z) := by"
"R1PrefixMassCollinearVisible.lean","16","theorem","R1_prefix_mass_collinear_visible","theorem R1_prefix_mass_collinear_visible {z : Complex} (hRadiusFloor : R1RadiusFloorSubsequenceAt z) (hCollinear : R1CollinearWindowModelAt z) (hLinearTail : forall k n : Nat, R1LinearTailFormulaAt k n z) (hPrefixBridge : R1RadiusFloorSubsequenceAt z -> R1CollinearWindowModelAt z -> (forall k n : Nat, R1LinearTailFormulaAt k n z) -> R1PrefixMassCollinearVisibleBoundAt z) : R1PrefixMassCollinearVisibleBoundAt z := by"
"R1PrefixMassFromRank1Aggregate.lean","12","theorem","R1_prefix_mass_from_rank1_aggregate","theorem R1_prefix_mass_from_rank1_aggregate {z : Complex} (hAggregate : R1Rank1AggregateWindowAt z) (hCollinear : R1CollinearRepresentationFromAggregateAt z) (hBoundBridge : R1CollinearRepresentationFromAggregateAt z -> R1PrefixMassCollinearVisibleBoundAt z -> R1PrefixMassBoundFromRank1AggregateAt z) (hCollinearVisible : R1PrefixMassCollinearVisibleBoundAt z) : R1PrefixMassBoundFromRank1AggregateAt z := by"
"R1PrefixSubsequenceDivergence.lean","14","theorem","R1_prefix_subsequence_divergence","theorem R1_prefix_subsequence_divergence {z : Complex} (hMassDiverges : R1TotalMassDivergesAt z) (hSubseqBridge : R1TotalMassDivergesAt z -> R1PrefixMassDivergesAlongSubseqAt z) : R1PrefixMassDivergesAlongSubseqAt z := by"
"R1RadiusfloorClosure.lean","14","theorem","R1_radiusfloor_closure","theorem R1_radiusfloor_closure {z : Complex} (hRadiusFloor : R1RadiusFloorTargetSubsequenceAt z) (hApplicability : R1RadiusFloorTargetSubsequenceAt z -> R1ClassicalMassApplicabilityAt z) (hClassicalMass : R1ClassicalMassApplicabilityAt z -> R1RadiusfloorClosurePrefixBoundAt z) (hPrefixEmbed : R1RadiusfloorClosurePrefixBoundAt z -> R1PrefixWindowDirectBoundAt z) (hForward : R1TailWindowBoundOnSubseqAt z -> R1PrefixWindowDirectBoundAt z) (hBackward : R1PrefixWindowDirectBoundAt z -> R1TailWindowBoundOnSubseqAt z) : R1RadiusfloorClosurePrefixBoundAt z /\ R1TailWindowBoundOnSubseqAt z := by"
"R1RadiusfloorKappaBottleneck.lean","17","theorem","R1_radiusfloor_kappa_bottleneck","theorem R1_radiusfloor_kappa_bottleneck {z : Complex} (hRadiusFloor : R1RadiusFloorSubsequenceAt z) (hTwoChannelEnergy : forall j : Nat, R1TwoChannelEnergyWindowAt j z) (hTraceCompare : forall k j : Nat, R1TwoChannelTraceCompareAt k j z) (hBottleneckBridge : R1RadiusFloorSubsequenceAt z -> (forall j : Nat, R1TwoChannelEnergyWindowAt j z) -> (forall k j : Nat, R1TwoChannelTraceCompareAt k j z) -> forall j : Nat, R1PrefixTraceKappaBottleneckAt j z) (hDivergenceBridge : (forall j : Nat, R1PrefixTraceKappaBottleneckAt j z) -> R1FrameGrowthDivergenceAt z) : (forall j : Nat, R1PrefixTraceKappaBottleneckAt j z) /\ R1FrameGrowthDivergenceAt z := by"
"R1RadiusFormula.lean","14","theorem","R1_radius_formula","theorem R1_radius_formula {n : Nat} {z : Complex} (hz : InUpperB21 z) (hCircleCase : R1CircleCaseAt n z) (hExpandedBridge : InUpperB21 z -> R1CircleCaseAt n z -> R1CircleExpandedAt n z) (hRadiusBridge : R1CircleExpandedAt n z -> R1CircleCaseAt n z -> R1RadiusFormulaAt n z) : R1CircleExpandedAt n z /\ R1RadiusFormulaAt n z := by"
"R1Rank1AggregateDetEquiv.lean","11","theorem","R1_rank1_aggregate_det_equiv","theorem R1_rank1_aggregate_det_equiv {z : Complex} (hForward : R1RankOneAggregateCriterionAt z -> R1AggregateDetZeroCriterionAt z) (hBackward : R1AggregateDetZeroCriterionAt z -> R1RankOneAggregateCriterionAt z) : R1RankOneAggregateCriterionAt z <-> R1AggregateDetZeroCriterionAt z := by"
"R1Rank1AggregateDetExpansion.lean","10","theorem","R1_rank1_aggregate_det_expansion","theorem R1_rank1_aggregate_det_expansion {z : Complex} (hExpansionBridge : R1RankOneAggregateCriterionAt z -> R1AggregateDetExpansionAt z) (hRankOneAggregate : R1RankOneAggregateCriterionAt z) : R1AggregateDetExpansionAt z := by"
"R1Rank1ClosureExcludesRadiusfloor.lean","15","theorem","R1_rank1_closure_excludes_radiusfloor","theorem R1_rank1_closure_excludes_radiusfloor {z : Complex} (hClosure : R1MassDivergenceInternalClosureAt z) (hExcludeBridge : R1MassDivergenceInternalClosureAt z -> R1RadiusFloorSubsequenceExcludedAt z) (hCollapseBridge : R1RadiusFloorSubsequenceExcludedAt z -> R1RadiusCollapseAllUpperAt z) : R1RadiusFloorSubsequenceExcludedAt z /\ R1RadiusCollapseAllUpperAt z := by"
"R1Rank1ClosureHypReform.lean","13","theorem","R1_rank1_closure_hyp_reform","theorem R1_rank1_closure_hyp_reform {z : Complex} (hExactReduction : (R1CS2ConditionAt z <-> R1KjUniformBoundAt z) /\ (R1KjUniformBoundAt z <-> R1PrefixMassUniformBoundAt z) /\ (R1PrefixMassUniformBoundAt z <-> R1TailWindowSubseqBoundAt z)) (hRadiusfloorClosure : R1RadiusFloorTargetSubsequenceAt z -> R1RadiusfloorClosurePrefixBoundAt z /\ R1TailWindowBoundOnSubseqAt z) (hReformBridge : ((R1CS2ConditionAt z <-> R1KjUniformBoundAt z) /\ (R1KjUniformBoundAt z <-> R1PrefixMassUniformBoundAt z) /\ (R1PrefixMassUniformBoundAt z <-> R1TailWindowSubseqBoundAt z)) -> (R1RadiusFloorTargetSubsequenceAt z -> R1RadiusfloorClosurePrefixBoundAt z /\ R1TailWindowBoundOnSubseqAt z) -> R1Rank1ClosureHypReformAt z) : R1Rank1ClosureHypReformAt z := by"
"R1Rank1ExactClosureReduction.lean","11","theorem","R1_rank1_exact_closure_reduction","theorem R1_rank1_exact_closure_reduction {z : Complex} (hCS2K : R1CS2ConditionAt z <-> R1KjUniformBoundAt z) (hKPrefix : R1KjUniformBoundAt z <-> R1PrefixMassUniformBoundAt z) (hPrefixTail : R1PrefixMassUniformBoundAt z <-> R1TailWindowSubseqBoundAt z) : (R1CS2ConditionAt z <-> R1KjUniformBoundAt z) /\ (R1KjUniformBoundAt z <-> R1PrefixMassUniformBoundAt z) /\ (R1PrefixMassUniformBoundAt z <-> R1TailWindowSubseqBoundAt z) := by"
"R1Rank1MixedFactor.lean","11","theorem","R1_rank1_mixed_factor","theorem R1_rank1_mixed_factor {z : Complex} (hLinear : forall k : Nat, R1Rank1StepLinearAt k z) (hMixedBridge : (forall k : Nat, R1Rank1StepLinearAt k z) -> forall p q : Nat, R1Rank1MixedFactorAt p q z) (hOrthBridge : (forall p q : Nat, R1Rank1MixedFactorAt p q z) -> forall p q : Nat, R1SymplecticOrthogonalityAt p q z) : (forall p q : Nat, R1Rank1MixedFactorAt p q z) /\ (forall p q : Nat, R1SymplecticOrthogonalityAt p q z) := by"
"R1Rank1RadiusfloorDichotomy.lean","11","theorem","R1_rank1_radiusfloor_dichotomy","theorem R1_rank1_radiusfloor_dichotomy {z : Complex} (hSplit : R1BoundedBranchAt z \/ R1DivergentBranchAt z) (hExclusive : R1BoundedBranchAt z -> R1DivergentBranchAt z -> False) : (R1BoundedBranchAt z \/ R1DivergentBranchAt z) /\ (R1BoundedBranchAt z -> R1DivergentBranchAt z -> False) := by"
"R1Rank1StepLinear.lean","13","theorem","R1_rank1_step_linear","theorem R1_rank1_step_linear {z : Complex} (hRankOne : forall k : Nat, R1RankOneBlockAt k z) (hTransport : forall k : Nat, R1TransportInvariantAt k z) (hLinearBridge : (forall k : Nat, R1RankOneBlockAt k z) -> (forall k : Nat, R1TransportInvariantAt k z) -> forall k : Nat, R1Rank1StepLinearAt k z) (hInverseBridge : (forall k : Nat, R1Rank1StepLinearAt k z) -> forall k : Nat, R1Rank1StepInverseLinearAt k z) : (forall k : Nat, R1Rank1StepLinearAt k z) /\ (forall k : Nat, R1Rank1StepInverseLinearAt k z) := by"
"R1Rank1TailwindowPrinciple.lean","13","theorem","R1_rank1_tailwindow_principle","theorem R1_rank1_tailwindow_principle {z : Complex} (hMassDiverges : R1TotalMassDivergesAt z) (hPrefixPrinciple : R1SubseqPrefixWindowPrincipleAt z) (hFiniteMassBridge : R1SubseqPrefixWindowPrincipleAt z -> R1FiniteTotalMassFromPrefixWindowAt z) (hCollapseBridge : R1TotalMassDivergesAt z -> R1FiniteTotalMassFromPrefixWindowAt z -> R1RadiusCollapseFromPrefixPrincipleAt z) : R1RadiusCollapseFromPrefixPrincipleAt z := by"
"R1Rank1TransportInvariance.lean","13","theorem","R1_rank1_transport_invariance","theorem R1_rank1_transport_invariance {z : Complex} (hz : InUpperB21 z) (hRankOne : forall k : Nat, R1RankOneBlockAt k z) (hHJHBridge : InUpperB21 z -> (forall k : Nat, R1RankOneBlockAt k z) -> forall k : Nat, R1HJHZeroAt k z) (hTransportBridge : InUpperB21 z -> (forall k : Nat, R1HJHZeroAt k z) -> forall k : Nat, R1TransportInvariantAt k z) : (forall k : Nat, R1HJHZeroAt k z) /\ (forall k : Nat, R1TransportInvariantAt k z) := by"
"R1SymplOrthCollinearEquiv.lean","13","theorem","R1_sympl_orth_collinear_equiv","theorem R1_sympl_orth_collinear_equiv {z : Complex} (hForward : R1PairwiseSymplOrthogonalityAt z -> R1OneDirectionWindowFamilyAt z) (hBackward : R1OneDirectionWindowFamilyAt z -> R1PairwiseSymplOrthogonalityAt z) : R1PairwiseSymplOrthogonalityAt z <-> R1OneDirectionWindowFamilyAt z := by"
"R1TailwindowDirectFiniteMass.lean","11","theorem","R1_tailwindow_direct_finite_mass","theorem R1_tailwindow_direct_finite_mass {z : Complex} (hPrefixWindow : R1PrefixWindowDirectBoundAt z) (hFiniteBridge : R1PrefixWindowDirectBoundAt z -> R1FiniteTotalMassFromPrefixWindowAt z) : R1FiniteTotalMassFromPrefixWindowAt z := by"
"R1TailwindowPrefixEquiv.lean","10","theorem","R1_tailwindow_prefix_equiv","theorem R1_tailwindow_prefix_equiv {z : Complex} (hForward : R1TailWindowBoundOnSubseqAt z -> R1PrefixWindowDirectBoundAt z) (hBackward : R1PrefixWindowDirectBoundAt z -> R1TailWindowBoundOnSubseqAt z) : R1TailWindowBoundOnSubseqAt z <-> R1PrefixWindowDirectBoundAt z := by"
"R1TwoChannelTraceCompare.lean","11","theorem","R1_two_channel_trace_compare","theorem R1_two_channel_trace_compare {z : Complex} (hFrame : forall k j : Nat, R1TwoChannelFrameAt k j z) (hCompareBridge : (forall k j : Nat, R1TwoChannelFrameAt k j z) -> forall k j : Nat, R1TwoChannelTraceCompareAt k j z) : (forall k j : Nat, R1TwoChannelFrameAt k j z) /\ (forall k j : Nat, R1TwoChannelTraceCompareAt k j z) := by"
"R1UniformEllipticityCollapse.lean","12","theorem","R1_uniform_ellipticity_collapse","theorem R1_uniform_ellipticity_collapse {z : Complex} (hMassDiverges : R1TotalMassDivergesAt z) (hUniformEllipticity : R1UniformEllipticityAt z) (hFiniteMass : R1UniformEllipticityAt z -> R1FiniteTotalMassFromUniformEllipticityAt z) (hCollapseBridge : R1TotalMassDivergesAt z -> R1FiniteTotalMassFromUniformEllipticityAt z -> R1RadiusCollapseFromUniformEllipticityAt z) : R1RadiusCollapseFromUniformEllipticityAt z := by"
"R1UniformEllipticityFiniteMass.lean","15","theorem","R1_uniform_ellipticity_finite_mass","theorem R1_uniform_ellipticity_finite_mass {z : Complex} (hRadiusFloor : R1RadiusFloorSubsequenceAt z) (hUniformEllipticity : R1UniformEllipticityAt z) (hDet1 : forall n : Nat, R1TruncationTransferDetOneAt n z) (hFiniteBridge : R1RadiusFloorSubsequenceAt z -> R1UniformEllipticityAt z -> (forall n : Nat, R1TruncationTransferDetOneAt n z) -> R1FiniteTotalMassFromUniformEllipticityAt z) : R1FiniteTotalMassFromUniformEllipticityAt z := by"
"R2DynamicEquilibrium.lean","18","theorem","R2_dynamic_equilibrium","theorem R2_dynamic_equilibrium {z : Complex} (hCocycle : R2SchurCocycleFamilyAt z) (hGyroGyration : R2GyroGyrationLawAt z) (hGyroAngleSeries : R2GyroAngleSeriesLawAt z) (hNormalBridge : R2SchurCocycleFamilyAt z -> R2GyroGyrationLawAt z -> R2GyroAngleSeriesLawAt z -> R2DynamicEquilibriumNormalFormAt z) (hLeakageBridge : R2SchurCocycleFamilyAt z -> R2LeakageAdditivityAt z) : R2DynamicEquilibriumNormalFormAt z /\ R2LeakageAdditivityAt z := by"
"ReverseRH.lean","17","theorem","reverse_RH_core","theorem reverse_RH_core {f : Complex -> Complex} (hZeroFree : ZeroFreeOnUpper f) (hConjZero : forall z : Complex, f z = 0 -> f (star z) = 0) : RiemannHypothesis f := by"
"ReverseRH.lean","24","theorem","reverse_RH_core_via_nevanlinna","theorem reverse_RH_core_via_nevanlinna {f H : Complex -> Complex} (hHerglotz : HerglotzOnUpperHalfPlane H) (hNevanlinnaExclusion : StripPoleExclusionViaNevanlinna f H) (hConjZero : forall z : Complex, f z = 0 -> f (star z) = 0) : RiemannHypothesis f := by"
"ReverseRH.lean","34","theorem","reverse_RH_via_conj_zero","theorem reverse_RH_via_conj_zero {f : Complex -> Complex} (hZeroFree : ZeroFreeOnUpper f) (hConjZero : forall z : Complex, f z = 0 -> f (star z) = 0) : RiemannHypothesis f := by"
"ReverseRH.lean","41","theorem","reverse_RH","theorem reverse_RH {f : Complex -> Complex} -- Core closure endpoint used for root-assumption reduction batches. (hZeroFree : ZeroFreeOnUpper f) (hConjZero : forall z : Complex, f z = 0 -> f (star z) = 0) : RiemannHypothesis f := by"
"ReverseRH.lean","49","theorem","reverse_RH_via_nevanlinna","theorem reverse_RH_via_nevanlinna {f H : Complex -> Complex} -- `hHerglotz` / `hNevanlinnaExclusion` instantiate the `lem:no_zeros_from_herglotz` route. (hHerglotz : HerglotzOnUpperHalfPlane H) (hNevanlinnaExclusion : StripPoleExclusionViaNevanlinna f H) (hConjZero : forall z : Complex, f z = 0 -> f (star z) = 0) : RiemannHypothesis f := by"
"ReverseRH.lean","60","theorem","reverse_RH_via_conjugation_symmetry","theorem reverse_RH_via_conjugation_symmetry {f : Complex -> Complex} (hZeroFree : ZeroFreeOnUpper f) (hConjSymm : ConjugationSymmetric f) : RiemannHypothesis f := by"
"ReverseRH.lean","69","theorem","reverse_RH_via_nevanlinna_conjugation_symmetry","theorem reverse_RH_via_nevanlinna_conjugation_symmetry {f H : Complex -> Complex} (hHerglotz : HerglotzOnUpperHalfPlane H) (hNevanlinnaExclusion : StripPoleExclusionViaNevanlinna f H) (hConjSymm : ConjugationSymmetric f) : RiemannHypothesis f := by"
"ReverseRH.lean","78","theorem","reverse_RH_via_xi_functional_symmetry","theorem reverse_RH_via_xi_functional_symmetry {f : Complex -> Complex} (hZeroFree : ZeroFreeOnUpper f) (hXiSymm : XiFunctionalSymmetry f) : RiemannHypothesis f := by"
"ReverseRH.lean","87","theorem","reverse_RH_via_nevanlinna_xi_functional_symmetry","theorem reverse_RH_via_nevanlinna_xi_functional_symmetry {f H : Complex -> Complex} (hHerglotz : HerglotzOnUpperHalfPlane H) (hNevanlinnaExclusion : StripPoleExclusionViaNevanlinna f H) (hXiSymm : XiFunctionalSymmetry f) : RiemannHypothesis f := by"
"ReverseRH.lean","96","theorem","reverse_RH_via_cayley","theorem reverse_RH_via_cayley {f H W : Complex -> Complex} -- `hGlobalSchur` + `hCayleyEquiv` corresponds to `prop:W_global_schur` + `lem:cayley_equiv`. (hGlobalSchur : WGlobalSchurOnUpperHalfPlane W) (hCayleyEquiv : HerglotzOnUpperHalfPlane H <-> SchurOnUpperHalfPlane W) (hNevanlinnaExclusion : StripPoleExclusionViaNevanlinna f H) (hConjZero : forall z : Complex, f z = 0 -> f (star z) = 0) : RiemannHypothesis f := by"
"ReverseRH.lean","108","theorem","reverse_RH_via_cayley_conjugation_symmetry","theorem reverse_RH_via_cayley_conjugation_symmetry {f H W : Complex -> Complex} (hGlobalSchur : WGlobalSchurOnUpperHalfPlane W) (hCayleyEquiv : HerglotzOnUpperHalfPlane H <-> SchurOnUpperHalfPlane W) (hNevanlinnaExclusion : StripPoleExclusionViaNevanlinna f H) (hConjSymm : ConjugationSymmetric f) : RiemannHypothesis f := by"
"ReverseRH.lean","119","theorem","reverse_RH_via_cayley_xi_functional_symmetry","theorem reverse_RH_via_cayley_xi_functional_symmetry {f H W : Complex -> Complex} (hGlobalSchur : WGlobalSchurOnUpperHalfPlane W) (hCayleyEquiv : HerglotzOnUpperHalfPlane H <-> SchurOnUpperHalfPlane W) (hNevanlinnaExclusion : StripPoleExclusionViaNevanlinna f H) (hXiSymm : XiFunctionalSymmetry f) : RiemannHypothesis f := by"
"RHFromAnchor.lean","26","theorem","rh_from_anchor","theorem rh_from_anchor {f : Complex -> Complex} (hFinalBridgeRH : HasOnlyRealZeros f) (hLogDerivHol : HasOnlyRealZeros f -> HolomorphicOnUpperHalfPlane (fun z => -(deriv f z) / f z)) (hLogDerivHerglotz : HasOnlyRealZeros f -> HerglotzOnUpperHalfPlane (fun z => -(deriv f z) / f z)) (hCayleySchur : forall H : Complex -> Complex, HerglotzOnUpperHalfPlane H -> SchurOnUpperHalfPlane (fun z => (1 + Complex.I * H z) / (1 - Complex.I * H z))) (hLstarRealization : forall H : Complex -> Complex, HerglotzOnUpperHalfPlane H -> HasCanonicalSystemEnergyRealization H) : HasOnlyRealZeros f /\ HolomorphicOnUpperHalfPlane (fun z => -(deriv f z) / f z) /\ HerglotzOnUpperHalfPlane (fun z => -(deriv f z) / f z) /\ SchurOnUpperHalfPlane (fun z => (1 + Complex.I * (-(deriv f z) / f z)) / (1 - Complex.I * (-(deriv f z) / f z))) /\ HasCanonicalSystemEnergyRealization (fun z => -(deriv f z) / f z) := by"
"RHFromLstar.lean","14","theorem","conjugation_symmetric_of_xi_functional_symmetry","theorem conjugation_symmetric_of_xi_functional_symmetry {f : Complex -> Complex} (hXiSymm : XiFunctionalSymmetry f) : ConjugationSymmetric f := by"
"RHFromLstar.lean","20","theorem","conj_zero_of_conjugation_symmetric","theorem conj_zero_of_conjugation_symmetric {f : Complex -> Complex} (hConjSymm : ConjugationSymmetric f) : forall z : Complex, f z = 0 -> f (star z) = 0 := by"
"RHFromLstar.lean","37","theorem","rh_from_lstar_core","theorem rh_from_lstar_core {f : Complex -> Complex} (hZeroFree : ZeroFreeOnUpper f) (hConjZero : forall z : Complex, f z = 0 -> f (star z) = 0) : RiemannHypothesis f := by"
"RHFromLstar.lean","56","theorem","zero_free_of_nevanlinna","theorem zero_free_of_nevanlinna {f H : Complex -> Complex} (hHerglotz : HerglotzOnUpperHalfPlane H) (hNevanlinnaExclusion : StripPoleExclusionViaNevanlinna f H) : ZeroFreeOnUpper f := by"
"RHFromLstar.lean","63","theorem","rh_from_lstar_core_via_nevanlinna","theorem rh_from_lstar_core_via_nevanlinna {f H : Complex -> Complex} (hHerglotz : HerglotzOnUpperHalfPlane H) (hNevanlinnaExclusion : StripPoleExclusionViaNevanlinna f H) (hConjZero : forall z : Complex, f z = 0 -> f (star z) = 0) : RiemannHypothesis f := by"
"RHFromLstar.lean","73","theorem","rh_from_lstar","theorem rh_from_lstar {f H : Complex -> Complex} (hHerglotz : HerglotzOnUpperHalfPlane H) (hNevanlinnaExclusion : StripPoleExclusionViaNevanlinna f H) (hConjZero : forall z : Complex, f z = 0 -> f (star z) = 0) : RiemannHypothesis f := by"
"RHFromLstar.lean","81","theorem","rh_from_lstar_via_conjugation_symmetry","theorem rh_from_lstar_via_conjugation_symmetry {f H : Complex -> Complex} (hHerglotz : HerglotzOnUpperHalfPlane H) (hNevanlinnaExclusion : StripPoleExclusionViaNevanlinna f H) (hConjSymm : ConjugationSymmetric f) : RiemannHypothesis f := by"
"RHFromLstar.lean","91","theorem","rh_from_lstar_via_xi_functional_symmetry","theorem rh_from_lstar_via_xi_functional_symmetry {f H : Complex -> Complex} (hHerglotz : HerglotzOnUpperHalfPlane H) (hNevanlinnaExclusion : StripPoleExclusionViaNevanlinna f H) (hXiSymm : XiFunctionalSymmetry f) : RiemannHypothesis f := by"
"RHFromLstar.lean","101","theorem","zero_free_and_conjugation_symmetry_suffice","theorem zero_free_and_conjugation_symmetry_suffice {f : Complex -> Complex} (hZeroFree : ZeroFreeOnUpper f) (hConjSymm : ConjugationSymmetric f) : RiemannHypothesis f := by"
"RHFromLstar.lean","110","theorem","zero_free_on_upper_not_sufficient","theorem zero_free_on_upper_not_sufficient : Exists fun f : Complex -> Complex => ZeroFreeOnUpper f /\ Not (RiemannHypothesis f) := by"
"RHFromLstar.lean","128","theorem","conjugation_symmetric_not_sufficient","theorem conjugation_symmetric_not_sufficient : Exists fun f : Complex -> Complex => ConjugationSymmetric f /\ Not (RiemannHypothesis f) := by"
"RTo1SchurLimit.lean","18","theorem","r_to_1_schur_limit","theorem r_to_1_schur_limit {z : Complex} (hUniformBound : R2SchurFamilyUniformBoundAt z) (hPointwiseLimit : R2PointwiseRToOneLimitAt z) (hLocalBridge : R2SchurFamilyUniformBoundAt z -> R2PointwiseRToOneLimitAt z -> R2LocallyUniformSchurLimitAt z) (hBoundaryBridge : R2LocallyUniformSchurLimitAt z -> R2SchurLimitBoundaryValuesAt z) : R2LocallyUniformSchurLimitAt z /\ R2SchurLimitBoundaryValuesAt z := by"
"SchurDeBranges.lean","21","theorem","schur_debranges","theorem schur_debranges {E Esharp W : Complex -> Complex} (hZeroFree : ZeroFreeOnUpper E) (hW : W = EsharpOverE E Esharp) (hSchurKernel : SchurOnUpperHalfPlane W <-> DeBrangesKernelPSD E) (hSchurWeakHB : SchurOnUpperHalfPlane W <-> WeakHermiteBiehler E) : (SchurOnUpperHalfPlane W <-> DeBrangesKernelPSD E) /\ (SchurOnUpperHalfPlane W <-> WeakHermiteBiehler E) := by"
"SchurLocalUpdates.lean","8","theorem","schur_step_formula_nonzero","theorem schur_step_formula_nonzero {S : Complex -> Complex} {alpha z : Complex} (halpha : S 0 = alpha) (hz : z ??0) : dslope S 0 z / (1 - conj alpha * S z) = (S z - alpha) / (z * (1 - conj alpha * S z)) := by"
"SchurLocalUpdates.lean","23","theorem","alpha_k1_exact","theorem alpha_k1_exact {S : Complex -> Complex} {alpha : Complex} (halpha : S 0 = alpha) (hS : AnalyticAt Complex S 0) (hrho : (1 - conj alpha * alpha) ??0) : AnalyticAt Complex (fun z => dslope S 0 z / (1 - conj alpha * S z)) 0 ??      (dslope S 0 0 / (1 - conj alpha * S 0) = deriv S 0 / (1 - conj alpha * alpha)) := by"
"SchurLocalUpdates.lean","40","theorem","bk1_exact_coeff","theorem bk1_exact_coeff {S : Complex -> Complex} {p : FormalMultilinearSeries Complex Complex Complex} {alpha : Complex} (hp : HasFPowerSeriesAt S p 0) (halpha : p.coeff 0 = alpha) (hrho : (1 - conj alpha * alpha) ??0) : deriv (fun z => dslope S 0 z / (1 - conj alpha * S z)) 0 = p.coeff 2 / (1 - conj alpha * alpha) + conj alpha * (p.coeff 1) ^ 2 / (1 - conj alpha * alpha) ^ 2 := by"
"SelfadjointCompact.lean","11","theorem","selfadjoint_compact","theorem selfadjoint_compact {z : Complex} (hSelfadjointBridge : SelfadjointCompactAt z) : SelfadjointCompactAt z := by"
"StieltjesDiffquot.lean","12","theorem","stieltjes_diffquot","theorem stieltjes_diffquot {z : Complex} (hDiffquotBridge : StieltjesDiffquotAt z) : StieltjesDiffquotAt z := by"
"TraceLowerBound.lean","15","theorem","trace_lower_bound","theorem trace_lower_bound {z : Complex} (hSchurBlocks : R1SchurHamiltonianBlockFamilyAt z) (hTraceBridge : R1SchurHamiltonianBlockFamilyAt z -> R1TraceLowerBoundAt z) (hMassBridge : R1TraceLowerBoundAt z -> R1MassDivergesFromTraceLowerBoundAt z) : R1TraceLowerBoundAt z /\ R1MassDivergesFromTraceLowerBoundAt z := by"
"VerticalConvolution.lean","13","theorem","vertical_convolution","theorem vertical_convolution {z : Complex} (hConvIdentity : XiAlphaVerticalConvolutionIdentityAt z) (hKernelBoundBridge : XiAlphaVerticalConvolutionIdentityAt z -> XiAlphaKernelBoundAt z) : XiAlphaVerticalConvolutionIdentityAt z /\ XiAlphaKernelBoundAt z := by"
"W0.lean","8","theorem","W0","theorem W0 {f H W : Complex -> Complex} (hF0Nonzero : f 0 != 0) (hFDeriv0 : deriv f 0 = 0) (hHdef : H = fun z => -(deriv f z) / f z) (hWdef : W = fun z => (1 + Complex.I * H z) / (1 - Complex.I * H z)) (hBridge : (f 0 != 0) -> deriv f 0 = 0 -> (H = fun z => -(deriv f z) / f z) -> (W = fun z => (1 + Complex.I * H z) / (1 - Complex.I * H z)) -> H 0 = 0 /\ W 0 = 1) : H 0 = 0 /\ W 0 = 1 := by"
"WBoundedCharacteristic.lean","11","theorem","W_bounded_characteristic","theorem W_bounded_characteristic {W : Complex -> Complex} (hNevanlinnaBridge : WBoundedCharacteristicOnStrips W) : WBoundedCharacteristicOnStrips W := by"
"WeylCalibration.lean","20","theorem","herglotz_transfer_of_eqOn","theorem herglotz_transfer_of_eqOn {s : Set Complex} {m1 m2 : Complex -> Complex} (heq : s.EqOn m1 m2) (h1 : IsHerglotzOn s m1) : IsHerglotzOn s m2 := by"
"WeylCalibration.lean","32","theorem","weyl_calibration_core","theorem weyl_calibration_core {s u : Set Complex} (hs : IsOpen s) (hconn : IsPreconnected s) (hu : IsOpen u) (hu_sub : Set.Subset u s) (hu_nonempty : Set.Nonempty u) {mWeyl mArith : Complex -> Complex} (hmWeyl : DifferentiableOn Complex mWeyl s) (hmArith : DifferentiableOn Complex mArith s) (hderiv_u : u.EqOn (deriv mWeyl) (deriv mArith)) {z0 : Complex} (hz0u : u z0) (h0 : mWeyl z0 = mArith z0) (hWeylHerglotz : IsHerglotzOn s mWeyl) : s.EqOn mWeyl mArith /\ IsHerglotzOn s mArith := by"
"WeylCalibration.lean","49","theorem","weyl_calibration_with_hb","theorem weyl_calibration_with_hb {s u : Set Complex} (hs : IsOpen s) (hconn : IsPreconnected s) (hu : IsOpen u) (hu_sub : Set.Subset u s) (hu_nonempty : Set.Nonempty u) {mWeyl mArith E A B : Complex -> Complex} (hmWeyl : DifferentiableOn Complex mWeyl s) (hmArith : DifferentiableOn Complex mArith s) (hderiv_u : u.EqOn (deriv mWeyl) (deriv mArith)) {z0 : Complex} (hz0u : u z0) (h0 : mWeyl z0 = mArith z0) (hWeylHerglotz : IsHerglotzOn s mWeyl) (hArithToHB : IsHerglotzOn s mArith -> IsHermiteBiehler E) (hHBToInterlace : IsHermiteBiehler E -> RealInterlacingData A B) : s.EqOn mWeyl mArith /\ IsHerglotzOn s mArith /\ IsHermiteBiehler E /\ RealInterlacingData A B := by"
"WeylDerivativeResolventSquare.lean","11","theorem","weyl_derivative_resolvent_square","theorem weyl_derivative_resolvent_square {z : Complex} (hPickTwoSides : PickKernelTwoSidesAt z) (hBridge : PickKernelTwoSidesAt z -> WeylDerivativeResolventSquareAt z) : WeylDerivativeResolventSquareAt z := by"
"WeylIsHerglotz.lean","11","theorem","weyl_is_herglotz","theorem weyl_is_herglotz {z : Complex} (hWeylBridge : WeylIsHerglotzAt z) : WeylIsHerglotzAt z := by"
"WGlobalSchur.lean","11","theorem","W_global_schur","theorem W_global_schur {W : Complex -> Complex} (hStripSchur : WStripSchurOnUpperStrip W) : WGlobalSchurOnUpperHalfPlane W := by"
"WInftyLimit.lean","10","theorem","W_infty_limit","theorem W_infty_limit {z : Complex} (hPinning : R2HInftyAsymptoticPinningAt z) (hWBridge : R2HInftyAsymptoticPinningAt z -> R2WInftyLimitAt z) : R2WInftyLimitAt z := by"
"WStripSchur.lean","12","theorem","W_strip_schur","theorem W_strip_schur {W : Complex -> Complex} (hBoundedCharacteristic : WBoundedCharacteristicOnStrips W) : WStripSchurOnUpperStrip W := by"
"WUnitReal.lean","11","theorem","W_unit_real","theorem W_unit_real {W : Complex -> Complex} (hUnitBridge : WUnitModulusOnReal W) : WUnitModulusOnReal W := by"
"XiAlphaToXi.lean","11","theorem","Xi_alpha_to_Xi","theorem Xi_alpha_to_Xi {z : Complex} (hConvIdentity : XiAlphaVerticalConvolutionIdentityAt z) (hNormalization : XiAlphaGaussianNormalizationNonzeroAt z) (hTransferBridge : XiAlphaVerticalConvolutionIdentityAt z -> XiAlphaGaussianNormalizationNonzeroAt z -> XiAlphaToXiTransferAt z) : XiAlphaToXiTransferAt z := by"
